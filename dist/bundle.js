!function(t){var n={};function e(s){if(n[s])return n[s].t;var i=n[s]={s,i:!1,t:{}};return t[s].call(i.t,i,i.t,e),i.i=!0,i.t}e.o=t,e.c=n,e.d=function(t,n,s){e.h(t,n)||Object.defineProperty(t,n,{l:!0,get:s})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"u",{value:!0})},e.m=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.u)return t;var s=Object.create(null);if(e.r(s),Object.defineProperty(s,"default",{l:!0,value:t}),2&n&&"string"!=typeof t)for(var i in t)e.d(s,i,function(n){return t[n]}.bind(null,i));return s},e.n=function(t){var n=t&&t.u?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.h=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e._=1)}([function(t,n){var e=542327876,s=131072,i=4,o=T("DXT1"),r=T("DXT3"),a=T("DXT5"),h=T("DX10"),l=116,u=512,c=3,f=2,m=31,d=0,p=1,_=2,S=3,g=4,v=7,w=20,x=21,b=28;function T(t){return t.charCodeAt(0)+(t.charCodeAt(1)<<8)+(t.charCodeAt(2)<<16)+(t.charCodeAt(3)<<24)}t.t=function(t){var n,T,M=new Int32Array(t,0,m);if(M[d]!==e)throw new Error("Invalid magic number in DDS header");if(!M[w]&i)throw new Error("Unsupported format, must contain a FourCC code");var E=M[x];switch(E){case o:n=8,T="dxt1";break;case r:n=16,T="dxt3";break;case a:n=16,T="dxt5";break;case l:T="rgba32f";break;case h:var y=new Uint32Array(t.slice(128,148));T=y[0];var A=y[1];y[2],y[3],y[4];if(A!==c||T!==f)throw new Error("Unsupported DX10 texture format "+T);T="rgba32f";break;default:throw new Error("Unsupported FourCC code: "+(N=E,String.fromCharCode(255&N,N>>8&255,N>>16&255,N>>24&255)))}var N;var F=M[_],O=1;F&s&&(O=Math.max(1,M[v]));var R=!1;M[b]&u&&(R=!0);var P,L=M[g],C=M[S],V=M[p]+4,I=L,D=C,H=[];E===h&&(V+=20);if(R)for(var B=0;B<6;B++){if("rgba32f"!==T)throw new Error("Only RGBA32f cubemaps are supported");L=I,C=D;for(var G=Math.log(L)/Math.log(2)+1,z=0;z<G;z++)P=L*C*16,H.push({offset:V,length:P,shape:[L,C]}),z<O&&(V+=P),L=Math.floor(L/2),C=Math.floor(C/2)}else for(var z=0;z<O;z++)P=Math.max(4,L)/4*Math.max(4,C)/4*n,H.push({offset:V,length:P,shape:[L,C]}),V+=P,L=Math.floor(L/2),C=Math.floor(C/2);return{shape:[I,D],images:H,format:T,flags:F,S:R}}},function(t,n,e){"use strict";e.r(n);const s=1e-6;let i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;Math.PI;function o(){let t=new i(3);return i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function r(t,n,e){let s=new i(3);return s[0]=t,s[1]=n,s[2]=e,s}function a(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function h(t,n,e,s){return t[0]=n,t[1]=e,t[2]=s,t}function l(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t}function u(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function c(t,n){let e=n[0],s=n[1],i=n[2],o=e*e+s*s+i*i;return o>0&&(o=1/Math.sqrt(o),t[0]=n[0]*o,t[1]=n[1]*o,t[2]=n[2]*o),t}function f(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function m(t,n,e){let s=n[0],i=n[1],o=n[2],r=e[0],a=e[1],h=e[2];return t[0]=i*h-o*a,t[1]=o*r-s*h,t[2]=s*a-i*r,t}function d(t,n,e){let s=n[0],i=n[1],o=n[2],r=e[3]*s+e[7]*i+e[11]*o+e[15];return r=r||1,t[0]=(e[0]*s+e[4]*i+e[8]*o+e[12])/r,t[1]=(e[1]*s+e[5]*i+e[9]*o+e[13])/r,t[2]=(e[2]*s+e[6]*i+e[10]*o+e[14])/r,t}function p(t,n,e,s){let i=[],o=[];return i[0]=n[0]-e[0],i[1]=n[1]-e[1],i[2]=n[2]-e[2],o[0]=i[0],o[1]=i[1]*Math.cos(s)-i[2]*Math.sin(s),o[2]=i[1]*Math.sin(s)+i[2]*Math.cos(s),t[0]=o[0]+e[0],t[1]=o[1]+e[1],t[2]=o[2]+e[2],t}function _(t,n,e,s){let i=[],o=[];return i[0]=n[0]-e[0],i[1]=n[1]-e[1],i[2]=n[2]-e[2],o[0]=i[2]*Math.sin(s)+i[0]*Math.cos(s),o[1]=i[1],o[2]=i[2]*Math.cos(s)-i[0]*Math.sin(s),t[0]=o[0]+e[0],t[1]=o[1]+e[1],t[2]=o[2]+e[2],t}const S=function(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t},g=function(t){let n=t[0],e=t[1],s=t[2];return Math.sqrt(n*n+e*e+s*s)};!function(){let t=o()}();class v{constructor(){this.g=!1,this.v=null,this.T=r(-1,-1,-1),this.M=r(1,1,1)}get min(){return this.T}get max(){return this.M}A(t){return a(this.T,t),this.g=!0,this}N(t){return a(this.M,t),this.g=!0,this}F(t){return t[0]>this.T[0]&&t[0]<this.M[0]&&t[1]>this.T[1]&&t[1]<this.M[1]&&t[2]>this.T[2]&&t[3]<this.M[2]}O(){return[[this.T[0],this.T[1],this.M[2]],[this.T[0],this.T[1],this.T[2]],[this.M[0],this.T[1],this.M[2]],[this.M[0],this.T[1],this.T[2]],[this.M[0],this.M[1],this.M[2]],[this.M[0],this.M[1],this.T[2]],[this.T[0],this.M[1],this.M[2]],[this.T[0],this.M[1],this.T[2]]]}R(t=!0){if(t&&!this.g&&this.v)return this.v;const n=new bt(!1,!1,8,xt.POINTS);n.P=3;const e=[];for(const t of this.O())e.push(...t);return this.v=new Mt(new Float32Array(e),n),this.g=!1,this.v}L(){const t=new bt(!1,!1,24,xt.LINES);t.P=3;const n=[],[e,s,i,o,r,a,h,l]=this.O();return n.push(...e,...i,...i,...r,...r,...h,...h,...e),n.push(...s,...o,...o,...a,...a,...l,...l,...s),n.push(...h,...l),n.push(...r,...a),n.push(...e,...s),n.push(...i,...o),new Mt(new Float32Array(n),t)}}function w(){let t=new i(4);return i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function x(t,n,e,s){let o=new i(4);return o[0]=t,o[1]=n,o[2]=e,o[3]=s,o}function b(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function T(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function M(t,n,e){let s=n[0],i=n[1],o=n[2],r=n[3];return t[0]=e[0]*s+e[4]*i+e[8]*o+e[12]*r,t[1]=e[1]*s+e[5]*i+e[9]*o+e[13]*r,t[2]=e[2]*s+e[6]*i+e[10]*o+e[14]*r,t[3]=e[3]*s+e[7]*i+e[11]*o+e[15]*r,t}!function(){let t=w()}();const E={TRIANGLES:4,C:{5120:WebGL2RenderingContext.BYTE,5121:WebGL2RenderingContext.UNSIGNED_BYTE,5122:WebGL2RenderingContext.SHORT,5123:WebGL2RenderingContext.UNSIGNED_SHORT,5125:WebGL2RenderingContext.UNSIGNED_INT,5126:WebGL2RenderingContext.FLOAT}},y=0,A=1,N=2,F=3,O="u_cameraPos",R="u_worldToCameraMatrix",P="u_cameraToWorldMatrix",L="u_perspectiveMatrix",C="u_modelWorldMatrix",V="u_modelViewMatrix",I="gbuf_position",D="gbuf_normal",H="gbuf_colormap",B="gbuf_metallic_roughness",G="u_hasTangent",z="https://raw.githubusercontent.com/ikatson/glTF-Sample-Models/master/2.0/Sponza/glTF/Sponza-dds.gltf";function W(){let t=new i(16);return i!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function k(t,n,e,s,i,o,r,a,h,l,u,c,f,m,d,p,_){return t[0]=n,t[1]=e,t[2]=s,t[3]=i,t[4]=o,t[5]=r,t[6]=a,t[7]=h,t[8]=l,t[9]=u,t[10]=c,t[11]=f,t[12]=m,t[13]=d,t[14]=p,t[15]=_,t}function U(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function j(t,n,e){let s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],h=n[5],l=n[6],u=n[7],c=n[8],f=n[9],m=n[10],d=n[11],p=n[12],_=n[13],S=n[14],g=n[15],v=e[0],w=e[1],x=e[2],b=e[3];return t[0]=v*s+w*a+x*c+b*p,t[1]=v*i+w*h+x*f+b*_,t[2]=v*o+w*l+x*m+b*S,t[3]=v*r+w*u+x*d+b*g,v=e[4],w=e[5],x=e[6],b=e[7],t[4]=v*s+w*a+x*c+b*p,t[5]=v*i+w*h+x*f+b*_,t[6]=v*o+w*l+x*m+b*S,t[7]=v*r+w*u+x*d+b*g,v=e[8],w=e[9],x=e[10],b=e[11],t[8]=v*s+w*a+x*c+b*p,t[9]=v*i+w*h+x*f+b*_,t[10]=v*o+w*l+x*m+b*S,t[11]=v*r+w*u+x*d+b*g,v=e[12],w=e[13],x=e[14],b=e[15],t[12]=v*s+w*a+x*c+b*p,t[13]=v*i+w*h+x*f+b*_,t[14]=v*o+w*l+x*m+b*S,t[15]=v*r+w*u+x*d+b*g,t}function $(t,n,e){let s,i,o,r,a,h,l,u,c,f,m,d,p=e[0],_=e[1],S=e[2];return n===t?(t[12]=n[0]*p+n[4]*_+n[8]*S+n[12],t[13]=n[1]*p+n[5]*_+n[9]*S+n[13],t[14]=n[2]*p+n[6]*_+n[10]*S+n[14],t[15]=n[3]*p+n[7]*_+n[11]*S+n[15]):(s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],h=n[5],l=n[6],u=n[7],c=n[8],f=n[9],m=n[10],d=n[11],t[0]=s,t[1]=i,t[2]=o,t[3]=r,t[4]=a,t[5]=h,t[6]=l,t[7]=u,t[8]=c,t[9]=f,t[10]=m,t[11]=d,t[12]=s*p+a*_+c*S+n[12],t[13]=i*p+h*_+f*S+n[13],t[14]=o*p+l*_+m*S+n[14],t[15]=r*p+u*_+d*S+n[15]),t}const X=j,Z=o();class Y{constructor(t,n,e){this.near=t,this.V=n,this.matrix=e}}class q{constructor(t=1){this.I=o(),this.D=!0,this.H=!0,this.B=!0,this.G=r(0,0,-1),this.W=r(0,0,1),this.k=r(0,1,0),this.I=o(),this.near=.1,this.V=15,this.U=45,this.j=t,this.$=W(),this.X=W(),this.Z=W()}get position(){return this.G}set position(t){this.G=t,this.update()}get forward(){return this.W}set forward(t){this.W=t,this.update()}get Y(){return this.k}set Y(t){this.k=t,this.update()}q(t){return this.V=t,this}update(){this.D=!0,this.H=!0,this.B=!0}K(){return this.H&&(this.J(),this.H=!1),this.X}tt(){return this.D&&(this.nt(),this.D=!1),this.Z}right(){return m(this.I,this.W,this.k),this.I}et(){return this.B&&(!function(t,n,e,s,i){let o,r=1/Math.tan(n/2);t[0]=r/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(o=1/(s-i),t[10]=(i+s)*o,t[14]=2*i*s*o):(t[10]=-1,t[14]=-2*s)}(this.$,this.U*Math.PI/180,this.j,this.near,this.V),this.B=!1),new Y(this.near,this.V,this.$)}st(){const t=[0,1,0];u(Z,this.forward,f(t,this.forward)),S(this.Y,t,Z),c(this.Y,this.Y),this.update()}clone(t){const n=t||new q;return a(n.position,this.position),a(n.forward,this.forward),a(n.Y,this.Y),n.near=this.near,n.V=this.V,n.j=this.j,n.update(),n}J(){const t=this.X,n=this.right();return k(t,n[0],this.Y[0],-this.forward[0],0,n[1],this.Y[1],-this.forward[1],0,n[2],this.Y[2],-this.forward[2],0,0,0,0,1),u(Z,this.position,-1),$(t,t,Z),t}nt(){const t=this.Z;var n,e;n=t,e=this.position,n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1;const s=this.right(),i=ht();return k(i,s[0],s[1],s[2],0,this.Y[0],this.Y[1],this.Y[2],0,-this.forward[0],-this.forward[1],-this.forward[2],0,0,0,0,1),j(t,t,i),t}}const K=(t,n,e)=>t<n?n:t>e?e:t;function J(t,n,e,s,i){return s+t/(e-n)*(i-s)}function Q(t,n){return J(Math.random(),0,1,t,n)}function tt(t,n){return r(Q(t,n),Q(t,n),Q(t,n))}function nt(t){let n=null;return function(){return n||(n=Ct(t))}}function et(t){let n=null;return()=>(null===n&&(n=t()),n)}function st(t){let n=new Array(1);return e=>(void 0===n[e]&&(n[e]=t()),n[e])}nt("resources/sphere.obj"),nt("resources/cube.obj");const it=W(),ot=o(),rt=w(),at=st(()=>new v),ht=function(){const t=W();return()=>(U(t),t)}(),lt=(()=>{const t=et(()=>new v),n=et(()=>new Float32Array(24)),e=et(()=>new Float32Array(72));return(s,i=!1,o=!0)=>{const r=s.tt();let a,h;a=i?t().R():t().L(),function(t,n){let e=n[0],s=n[1],i=n[2],o=n[3],r=n[4],a=n[5],h=n[6],l=n[7],u=n[8],c=n[9],f=n[10],m=n[11],d=n[12],p=n[13],_=n[14],S=n[15],g=e*a-s*r,v=e*h-i*r,w=e*l-o*r,x=s*h-i*a,b=s*l-o*a,T=i*l-o*h,M=u*p-c*d,E=u*_-f*d,y=u*S-m*d,A=c*_-f*p,N=c*S-m*p,F=f*S-m*_,O=g*F-v*N+w*A+x*y-b*E+T*M;O&&(O=1/O,t[0]=(a*F-h*N+l*A)*O,t[1]=(i*N-s*F-o*A)*O,t[2]=(p*T-_*b+S*x)*O,t[3]=(f*b-c*T-m*x)*O,t[4]=(h*y-r*F-l*E)*O,t[5]=(e*F-i*y+o*E)*O,t[6]=(_*w-d*T-S*v)*O,t[7]=(u*T-f*w+m*v)*O,t[8]=(r*N-a*y+l*M)*O,t[9]=(s*y-e*N-o*M)*O,t[10]=(d*b-p*w+S*g)*O,t[11]=(c*w-u*b-m*g)*O,t[12]=(a*E-r*A-h*M)*O,t[13]=(e*A-s*E+i*M)*O,t[14]=(p*v-d*x-_*g)*O,t[15]=(u*x-c*v+f*g)*O)}(it,s.et().matrix),h=o?i?n():e():i?new Float32Array(24):new Float32Array(72);for(const t of a.iterator(yt)){const n=rt;if(3!=t.it-t.ot)throw new Error("unsupported length of cubeVertices, should be 3");n[0]=a.rt[t.ot],n[1]=a.rt[t.ot+1],n[2]=a.rt[t.ot+2],n[3]=1,M(n,n,it),T(n,n,1/n[3]),M(n,n,r),h[t.ot]=n[0],h[t.ot+1]=n[1],h[t.ot+2]=n[2]}return new Mt(h,a.at)}})(),ut=(()=>{const t=new q;return n=>(t.forward=n,t.st(),t.update(),t.K())})(),ct=(()=>{const t=et(()=>(new v).R()),n=new Array(1),e=o(),s=st(()=>new v);return(i,o,r=null,a=null,l=!1)=>{let u=null;r=r||(t=>!0);const c=e=>{if(e.ht&&e.ht.lt||e.children.forEach(c),!e.ht||!r(e))return;X(it,o,e.transform.ut());const i=e.ht.dt.R(!0).ft(it,t()).ct(s(0));null===u?((u=a||s(1)).A(i.min),u.N(i.max)):(n[0]=i,u=Tt(n,!1,u,u))};return i.children.forEach(c),u&&l&&i.pt.forEach(t=>{d(ot,t.object.transform.position,o);const i=s(0),r=t._t+.1;i.A(h(e,ot[0]-r,ot[1]-r,ot[2]-r)),i.N(h(e,ot[0]+r,ot[1]+r,ot[2]+r)),n[0]=i,u=Tt(n,!1,u,u)}),null===u&&(u=a||s(1)),u}})(),ft=(t,n,e=.1,s=1,i=null)=>{const o=ct(n,t.K(),i,at(0),!0);return t.near=Math.max(e,-o.max[2]),t.V=Math.max(s,-o.min[2]),t.update(),t},mt=new Y(0,1,W()),dt=(()=>{const t=at;return(n,e,s,i)=>{const o=ut(n.direction);i=i||new Y(0,1,W());let r=lt(e,!0,!0).St(o).ct(t(0)),a=ct(s,o,t=>!t.mesh||t.mesh.gt,t(2));null===a&&(a=t(2));const h=it,l=Math.max(a.min[0],r.min[0]),u=Math.min(a.max[0],r.max[0]),c=Math.max(a.min[1],r.min[1]),f=Math.min(a.max[1],r.max[1]),m=a.min[2],d=a.max[2];return((t,n,e,s,i,o,r)=>{const a=1/(r-o),h=1/(i-s),l=1/(e-n);k(t,2*l,0,0,0,0,2*h,0,0,0,0,-2*a,0,-(e+n)*l,-(s+i)*h,(r+o)*a,1)})(h,l,u,c,f,m,d),j(i.matrix,h,o),i.near=m,i.V=d,i}})();function pt(t,n,e){if(t.has(n))return t.get(n);const s=e(n);return t.set(n,s),s}const _t=4,St=4,gt=2,vt=new Array(1),wt=w();var xt;!function(t){t[t.TRIANGLES=WebGL2RenderingContext.TRIANGLES]="TRIANGLES",t[t.LINES=WebGL2RenderingContext.LINES]="LINES",t[t.LINE_STRIP=WebGL2RenderingContext.LINE_STRIP]="LINE_STRIP",t[t.POINTS=WebGL2RenderingContext.POINTS]="POINTS",t[t.TRIANGLE_STRIP=WebGL2RenderingContext.TRIANGLE_STRIP]="TRIANGLE_STRIP"}(xt||(xt={}));class bt{constructor(t,n,e,s){this.P=St,this.vt=St,this.wt=gt,this.xt=xt.TRIANGLES,this.bt=t,this.Tt=n,this.Mt=e,this.xt=s||this.xt}Et(){return this.yt()/_t}yt(){let t=this.P*_t;return this.bt&&(t+=this.vt*_t),this.Tt&&(t+=this.wt*_t),t}At(){return _t*this.P}Nt(){return this.At()+(this.bt?this.vt*_t:0)}}const Tt=(()=>{const t=o(),n=o(),e=(t,n,e,s)=>{for(let i=0;i<t.length;i++)t[i]=s(t[i],n[e+i])};return(s,i=!1,o,r)=>{o=o||new v,r?(a(t,r.min),a(n,r.max)):(h(t,1/0,1/0,1/0),h(n,-1/0,-1/0,-1/0));for(let i=0;i<s.length;i++){const o=s[i];if(null!==o)if(o instanceof Mt)for(const s of o.iterator(yt))e(t,o.rt,s.ot,Math.min),e(n,o.rt,s.ot,Math.max);else o instanceof v&&(e(t,o.min,0,Math.min),e(n,o.max,0,Math.max))}return o.A(t),o.N(n),o}})();class Mt{constructor(t,n){this.rt=t,this.at=n}Ft(t){return new Pt(t,this)}translate(t){const n=new Mt(new Float32Array(this.rt.length),this.at);return this.ft(t,n)}St(t){return this.Ot(t,this.rt),this}Ot(t,n){for(const e of this.iterator(yt)){3===e.it-e.ot?(ot[0]=this.rt[e.ot],ot[1]=this.rt[e.ot+1],ot[2]=this.rt[e.ot+2],d(ot,ot,t),n.set(ot,e.ot)):(wt[0]=this.rt[e.ot],wt[1]=this.rt[e.ot+1],wt[2]=this.rt[e.ot+2],wt[3]=this.rt[e.ot+3],M(wt,wt,t),n.set(wt,e.ot));for(let t=e.Rt;t<e.Pt;t++)n[t]=this.rt[t]}return n}ft(t,n){return this.Ot(t,n.rt),n.at=this.at,n}ct(t){return vt[0]=this,Tt(vt,!1,t)}iterator(t){return(t=t||new Et(this)).initialize(this),t}}class Et{constructor(t){this.Lt=-1,this.initialize(t)}get done(){return this.Lt>=this.data.at.Mt}get value(){return this.done?null:this}initialize(t){this.data=t,this.Lt=-1}Ct(){const t=this.data.at,n=this.Lt*t.Et(),e=n+t.P,s=t.bt?e+t.vt:e;this.ot=n,this.it=n+t.P,this.Rt=e,this.Vt=t.bt?e+t.vt:e,this.It=s,this.Pt=t.Tt?s+t.wt:s}[Symbol.iterator](){return this}next(){return this.Lt++,this.Ct(),this}}const yt=new Et(null);class At{constructor(t,n){this.Ht=t.createBuffer(),t.bindVertexArray(null),t.bindBuffer(t.ARRAY_BUFFER,this.Ht),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)}rt(){return this.Ht}delete(t){t.deleteBuffer(this.Ht),this.Ht=null}target(){return WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER}}class Nt{constructor(t,n){this.Ht=t.createBuffer(),t.bindVertexArray(null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.Ht),t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)}rt(){return this.Ht}delete(t){t.deleteBuffer(this.Ht),this.Ht=null}target(){return WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER}}class Ft{constructor(t,n,e=0,s=0){this.Ht=t,this.Bt=n,this.Gt=e,this.zt=s}get byteLength(){return this.Bt}get byteOffset(){return this.Gt}get byteStride(){return this.zt}get rt(){return this.Ht}}class Ot{constructor(t,n){this.Wt=t,this.kt=n}get Ut(){return this.Wt}get data(){return this.kt}get jt(){return this.data.rt.rt()}$t(){return E.C[this.Wt.componentType]}Xt(){switch(this.Wt.type){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:throw new Error(`Unknown type ${this.Wt.type}`)}}Zt(t,n){-1!==n&&(t.bindBuffer(t.ARRAY_BUFFER,this.jt),t.enableVertexAttribArray(n),t.vertexAttribPointer(n,this.Xt(),this.$t(),this.Ut.normalized||!1,this.data.byteStride,(this.data.byteOffset||0)+(this.Ut.byteOffset||0)))}}class Rt{constructor(t,n,e,s,i,o,r){this.indices=n,this.position=e,this.Yt=s,this.qt=i,this.Kt=o,this.Jt=this.Qt(t),this.tn=r}nn(){return this.tn}delete(t){console.log("delete called on GLArrayBufferGLTF, not sure what to do")}en(t,n){void 0===n&&(n=t.TRIANGLES),t.bindVertexArray(this.Jt),this.indices?t.drawElements(n,this.indices.Ut.count,this.indices.$t(),this.indices.Ut.byteOffset):t.drawArrays(n,0,this.position.Ut.count)}bt(){return!!this.qt}sn(){return!!this.Kt}in(){return!!this.Yt}Qt(t){const n=t.createVertexArray();try{t.bindVertexArray(n),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indices.jt);const e=!!this.qt,s=!!this.Yt,i=!!this.Kt;this.on(t,y),e&&this.rn(t,A),s&&this.an(t,N),i&&this.hn(t,F)}catch(e){throw t.deleteVertexArray(n),e}return n}rn(t,n){this.qt.Zt(t,n)}on(t,n){this.position.Zt(t,n)}an(t,n){this.Yt.Zt(t,n)}hn(t,n){this.Kt.Zt(t,n)}}class Pt{constructor(t,n,e){void 0===e&&(e=t.STATIC_DRAW),this.buffer=t.createBuffer(),this.at=n.at,this.Jt=this.ln(t),t.bindBuffer(t.ARRAY_BUFFER,this.buffer),t.bufferData(t.ARRAY_BUFFER,n.rt,e),t.bindVertexArray(null),this.tn=n.ct()}nn(){return this.tn}en(t,n){t.bindVertexArray(this.Jt),t.drawArrays(n||this.at.xt,0,this.at.Mt)}delete(t){t.deleteVertexArray(this.Jt),t.deleteBuffer(this.buffer)}bt(){return this.at.bt}sn(){return!1}in(){return this.at.Tt}on(t,n){t.enableVertexAttribArray(n),t.vertexAttribPointer(n,this.at.P,t.FLOAT,!1,this.at.yt(),0)}rn(t,n){if(!this.at.bt)throw new Error("buf has no normals");-1!=n&&(t.enableVertexAttribArray(n),t.vertexAttribPointer(n,this.at.vt,t.FLOAT,!1,this.at.yt(),this.at.At()))}an(t,n){if(!this.at.Tt)throw new Error("buf has no UVs");-1!=n&&(t.enableVertexAttribArray(n),t.vertexAttribPointer(n,this.at.wt,t.FLOAT,!1,this.at.yt(),this.at.Nt()))}ln(t){const n=t.createVertexArray();try{t.bindVertexArray(n),t.bindBuffer(t.ARRAY_BUFFER,this.buffer);const e=this.at.bt,s=this.at.Tt;this.on(t,y),e&&this.rn(t,A),s&&this.an(t,N)}catch(e){t.deleteVertexArray(n)}return n}}class Lt{constructor(t=!1){this.un=new TextDecoder("utf-8"),this.cn="",this.fn=0,this.mn=[],this.dn=[],this.pn=[],this.bt=!1,this.Tt=!1,this._n=[],this.Sn=t}gn(){const t=new bt(this.bt,this.Tt,3*this.vn(),xt.TRIANGLES);return t.P=3+(this.Sn?1:0),t.vt=3+(this.Sn?1:0),new Mt(new Float32Array(this._n),t)}vn(){return this.fn}wn(t){if(t.startsWith("v ")){t.split(" ").slice(1).forEach(t=>{this.mn.push(parseFloat(t))})}else if(t.startsWith("vt ")){t.split(" ").slice(1).forEach(t=>{this.pn.push(parseFloat(t))}),this.Tt=!0}else if(t.startsWith("f ")){t.split(" ").slice(1).forEach(n=>{const e=n.split("/"),s=3*(parseInt(e[0])-1),i=2*(parseInt(e[1])-1),o=3*(parseInt(e[2])-1);if(this.bt&&void 0===o)throw new Error(`incomplete object, has normals, but can't parse normals from line: ${t}`);if(this.Tt&&void 0===i)throw new Error(`incomplete object, has normals, but can't parse UVs from line: ${t}`);this._n.push(this.mn[s]),this._n.push(this.mn[s+1]),this._n.push(this.mn[s+2]),this.Sn&&this._n.push(1),this.bt&&(this._n.push(this.dn[o]),this._n.push(this.dn[o+1]),this._n.push(this.dn[o+2]),this.Sn&&this._n.push(0)),this.Tt&&(this._n.push(this.pn[i]||0),this._n.push(1-this.pn[i+1]||0))}),this.fn+=1}else if(t.startsWith("vn ")){t.split(" ").slice(1).forEach(t=>{this.dn.push(parseFloat(t))}),this.bt=!0}}xn(t){const n=this.un.decode(t,{stream:!0}).split("\n");n[0]=this.cn+n[0],this.cn=n.pop(),n.forEach(t=>this.wn(t))}bn(){""!=this.cn&&(this.wn(this.cn),this.cn="")}clear(){this.cn="",this.mn=[],this.dn=[],this._n=[],this.fn=0,this.bt=!1,this.Tt=!1}}async function Ct(t,n,e){const s=await fetch(t);if(n&&n({headers:s.headers}),s.body){const i=s.body.getReader(),o=e||new Lt;for(;;){const{done:t,value:e}=await i.read();if(t)break;o.xn(e),n&&n({length:e.length})}return o.bn(),console.log(`fetched object from ${t}`),o}{const t=e||new Lt,n=await s.arrayBuffer();return t.xn(n),t.bn(),t}}class Vt extends Error{}class It extends Vt{}class Dt extends Vt{}function Ht(t,n,e){return t.replace(new RegExp(`#define ${n} .*`),`#define ${n} ${e}`)}class Bt{constructor(t,n,e){this.Tn=!1,e="#version 300 es\n"+e;let s=t.createShader(n);if(t.shaderSource(s,e),t.compileShader(s),!t.getShaderParameter(s,t.COMPILE_STATUS)){let n=t.getShaderInfoLog(s);throw t.deleteShader(s),new Dt(n+"\n\n\n"+function(t){let n=1,e=[];return t.split("\n").forEach(t=>{e.push(`${n} ${t}`),n+=1}),e.join("\n")}(e))}this.Mn=s}En(t){this.Tn=t}yn(){return this.Tn}An(){return this.Mn}delete(t){t.deleteShader(this.Mn),this.Mn=null}}class Gt{constructor(t,n,e){if(this.Nn=new Map,this.Fn=new Map,this.On=t.createProgram(),t.attachShader(this.On,n.An()),t.attachShader(this.On,e.An()),t.linkProgram(this.On),this.ot=n,this.Rn=e,!t.getProgramParameter(this.On,t.LINK_STATUS)){let n=t.getProgramInfoLog(this.On);throw t.deleteProgram(this.On),new It(n)}}Pn(t){return t.useProgram(this.Ln()),this}Ln(){return this.On}Cn(t){this.delete(t),this.Rn.yn()&&this.Rn.delete(t),this.ot.yn()&&this.ot.delete(t)}delete(t){t.deleteProgram(this.On)}getAttribLocation(t,n){const e=this.Nn.get(n);if(void 0!==e)return e;const s=t.getAttribLocation(this.On,n);return this.Nn.set(n,s),s}getUniformLocation(t,n){const e=this.Fn.get(n);if(void 0!==e)return e;const s=t.getUniformLocation(this.On,n);return this.Fn.set(n,s),s}}class zt extends Bt{constructor(t,n){super(t,t.FRAGMENT_SHADER,n)}}class Wt extends Bt{constructor(t,n){super(t,t.VERTEX_SHADER,n)}}class kt{constructor(){this.Vn=[],this.In=[],this.Dn=new Map,this.Hn=new Map,this.precision="highp"}clone(){const t=new kt;return t.Vn=this.Vn.slice(),t.In=this.In.slice(),this.Dn.forEach((n,e)=>{t.Dn.set(e,n)}),this.Hn.forEach((n,e)=>{t.Hn.set(e,n)}),t.precision=this.precision,t}Bn(t){return this.precision=t,this}Gn(t,n){return n&&this.Dn.set(t,"1"),this}zn(t,n){return this.Dn.set(t,n),this}Wn(t,n){return this.Hn.set(t,n),this}kn(t){return this.In.push(t),this}Un(t){return this.Vn.push(t),this}jn(t){return t.Vn.forEach(t=>{this.Vn.push(t)}),t.In.forEach(t=>{this.In.push(t)}),t.Dn.forEach((t,n)=>{this.Dn.set(n,t)}),t.Hn.forEach((t,n)=>{this.Hn.set(n,t)}),this}$n(){const t=[];return t.push(`precision ${this.precision} float;`),this.Dn.forEach((n,e)=>{t.push(`#define ${e} ${n}`)}),this.Vn.forEach(n=>{this.Hn.forEach((t,e)=>{n=Ht(n,e,t)}),t.push(n)}),this.In.forEach(n=>{this.Hn.forEach((t,e)=>{n=Ht(n,e,t)}),t.push(n)}),t.join("\n")}}class Ut{constructor(t,n){this.Xn=n,this.ot=new Wt(t,"\n        layout(location = 0) in vec2 a_pos;\n        \n        uniform float percent;\n        out vec2 v_pos;\n\n        void main() {\n            gl_Position = vec4((a_pos.x + 1.) * percent - 1., a_pos.y * 0.05, 0., 1.);\n            v_pos = a_pos;\n        }\n        "),this.Rn=new zt(t,"\n        precision highp float;\n        in vec2 v_pos;\n        out vec4 color;\n        uniform float percent;\n        \n        void main() {\n            // color = vec4(0.5, 1., 1., 1.);\n\n            // just some random crap to test that variables work.\n            // looks OK in the end, so left it.\n            color = vec4(v_pos / 2. + 0.5, percent, 1.);\n        }\n        "),this.Mn=new Gt(t,this.ot,this.Rn),this.Zn=this.Mn.getUniformLocation(t,"percent")}delete(t){this.Rn.delete(t)}}class jt{constructor(t,n){this.Yn=n}qn(t){this.Yn.Mn.Pn(t)}Kn(t,n){t.uniform1f(this.Yn.Zn,n),this.Yn.Xn.en(t)}delete(){}}class $t{constructor(){this.object=null}Jn(t){return this.object=t,this}}class Xt extends $t{constructor(t){super(),this.gt=!0,this.Qn=!0,this.te=void 0,Array.isArray(t)?this.primitives=t:this.primitives=[t]}ne(t){return this.te=t,this}ee(t){return this.gt=t,this}se(t){return this.Qn=t,this}en(t){for(let n=0;n<this.primitives.length;n++){this.primitives[n].en(t,this.te)}}}class Zt extends $t{constructor(t){super(),this.visible=!1,this.lt=!1,this.dt=t}ie(t){return this.lt=t,this}oe(t){return this.re||(this.re=new Pt(t,this.dt.L())),this.re}}class Yt extends $t{constructor(){super(...arguments),this.color=r(1,1,1),this.ae=1}}class qt extends Yt{constructor(){super(...arguments),this.direction=r(0,-1,0)}}class Kt extends Yt{constructor(){super(...arguments),this._t=1}}class Jt extends $t{constructor(t){super(),this.he=W(),this.le=W(),this.object=t,this.position=r(0,0,0),this.rotation=r(0,0,0),this.scale=r(1,1,1),this.ue(),this.ce()}ut(){return this.he}fe(){return this.le}ce(){var t,n;t=this.he,n=this.fe(),t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15];const e=this.he;let s=this.object.parent;for(;s;)j(e,s.transform.fe(),e),s=s.parent;return e}ue(){U(this.le);const t=this.le;return $(t,t,this.position),function(t,n,e){let s=e[0],i=e[1],o=e[2];t[0]=n[0]*s,t[1]=n[1]*s,t[2]=n[2]*s,t[3]=n[3]*s,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=n[7]*i,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=n[11]*o,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]}(t,t,this.scale),function(t,n,e){let s=Math.sin(e),i=Math.cos(e),o=n[4],r=n[5],a=n[6],h=n[7],l=n[8],u=n[9],c=n[10],f=n[11];n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=o*i+l*s,t[5]=r*i+u*s,t[6]=a*i+c*s,t[7]=h*i+f*s,t[8]=l*i-o*s,t[9]=u*i-r*s,t[10]=c*i-a*s,t[11]=f*i-h*s}(t,t,this.rotation[0]),function(t,n,e){let s=Math.sin(e),i=Math.cos(e),o=n[0],r=n[1],a=n[2],h=n[3],l=n[8],u=n[9],c=n[10],f=n[11];n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=o*i-l*s,t[1]=r*i-u*s,t[2]=a*i-c*s,t[3]=h*i-f*s,t[8]=o*s+l*i,t[9]=r*s+u*i,t[10]=a*s+c*i,t[11]=h*s+f*i}(t,t,this.rotation[1]),function(t,n,e){let s=Math.sin(e),i=Math.cos(e),o=n[0],r=n[1],a=n[2],h=n[3],l=n[4],u=n[5],c=n[6],f=n[7];n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=o*i+l*s,t[1]=r*i+u*s,t[2]=a*i+c*s,t[3]=h*i+f*s,t[4]=l*i-o*s,t[5]=u*i-r*s,t[6]=c*i-a*s,t[7]=f*i-h*s}(t,t,this.rotation[2]),t}update(){this.ue(),this.ce(),this.object.children.forEach(t=>t.transform.update())}}class Qt extends $t{constructor(t){super(),this.material=t}}class tn{constructor(t){this.children=[],this.me=null,this.de=null,this.pe=null,this._e=null,this.Se=new Jt(this),this.name=t}get transform(){return this.Se}set transform(t){this.Se=t,t.object=this}get mesh(){return this.me}set mesh(t){this.me=t,t.object=this}get ge(){return this.de}set ge(t){this.de=t,t.object=this}get ve(){return this.pe}set ve(t){this.pe=t,t.object=this}get ht(){return this._e}set ht(t){this._e=t,t.object=this}we(t){this.children.push(t),t.parent=this,t.Se.update()}xe(){const t=[];let n=this;for(;n;)t.push(n.name),n=n.parent;return t.reverse(),t.join(" / ")}}class nn{constructor(t){this.h=new tn(t)}be(t){return this.h.mesh=new Xt(t),this.h.ht=new Zt(t.nn()),this}Te(t){return this.h.mesh=t,t.Jn(this.h),this}Me(t){return this.h.ve=t,t.object=this.h,this}Ee(t){return this.h.ge=t,t.object=this.h,this}ye(t){return this.h.ht=t,t.object=this.h,this}Ae(t){return this.h.material=t,t.object=this.h,this}$n(){return this.h}}function en(t,n){n=n||1;const e=new nn("a light").Ee(new Kt).$n();return e.transform.position=tt(-t,t),e.transform.scale=r(.1,.1,.1),e.transform.update(),e.ge.color=c(e.ge.color,tt(0,1)),e.ge.ae=n,e.ge}class sn{constructor(){this.children=[],this.Ne=[],this.pt=[]}we(t){this.children.push(t),t.parent=null,t.transform.update()}}const on="\nuniform sampler2D gbuf_position;\nuniform sampler2D gbuf_normal;\nuniform sampler2D gbuf_colormap;\nuniform sampler2D gbuf_metallic_roughness;\n\nvec4 read_gbuffer_normal(vec2 pos) {\n    vec3 val = texture(gbuf_normal, pos).xyz;\n    bool zIsNegative = false;\n    if (val.x > 1.5) {\n        val.x -= 3.;\n        zIsNegative = true;\n    }\n    // clamp is for float error correction\n    val.z = sqrt(clamp(1. - val.x * val.x - val.y * val.y, 0., 1.));\n    if (zIsNegative) {\n        val.z = -val.z;\n    }\n    val = normalize(val);\n    return vec4(val, 0.);\n}\n\nstruct metallicRoughness {\n    float metallic;\n    float roughness;\n};\n\nvoid gbufferMetallicRoughness(vec2 coord, out float metallic, out float roughness) {\n    vec4 tx = texture(gbuf_metallic_roughness, coord);\n    metallic = tx.r;\n    roughness = tx.g;\n    return;\n}\n\n#define GBUFFER_POSITION(coord) (texture(gbuf_position, coord))\n#define GBUFFER_NORMAL(coord) (read_gbuffer_normal(coord))\n#define GBUFFER_ALBEDO(coord) (texture(gbuf_colormap, coord))\n#define GBUFFER_MR(coord, metallic, roughness)     gbufferMetallicRoughness(coord, metallic, roughness)\n",rn="\nin vec2 v_pos;\nin vec2 tx_pos;\n",an="\nuniform vec3 u_cameraPos;\nuniform mat4 u_modelViewMatrix;\nuniform mat4 u_modelWorldMatrix;\nuniform mat4 u_worldToCameraMatrix;\nuniform mat4 u_cameraToWorldMatrix;\nuniform mat4 u_perspectiveMatrix;\n",hn=(new kt).Un(rn).Un(on).kn("\nlayout(location = 0) out vec4 color;\n\nuniform sampler2D u_ssaoTx;\nuniform sampler2D u_shadowmapTx;\n\nuniform float u_lightNear;\nuniform float u_lightFar;\n\nfloat eye_space_z(float depth, float near, float far) {\n    float eye_z = near * far / ((depth * (far - near)) - far);\n    float val = ( eye_z - (-near) ) / ( -far - (-near) );\n    return val;\n} \n\nvoid main() {\n    #ifdef SHOW_SSAO\n    color = vec4(vec3(texture(u_ssaoTx, tx_pos).r), 1.);\n    return;\n    #endif\n\n    vec4 normal = GBUFFER_NORMAL(tx_pos);\n    vec4 pos = GBUFFER_POSITION(tx_pos);\n    vec4 albedo = GBUFFER_ALBEDO(tx_pos);\n    \n    float metallic;\n    float roughness;\n    GBUFFER_MR(tx_pos, metallic, roughness);\n\n    #ifdef SHOW_NORMALS\n    color = vec4(normal.xyz * .5 + .5, pos.a);\n    // color = normal;\n    return;\n    #endif\n\n    #ifdef SHOW_POSITIONS\n    color = pos;\n    return;\n    #endif\n\n    #ifdef SHOW_COLORS\n    color = albedo;\n    return;\n    #endif\n    \n    #ifdef SHOW_METALLIC\n    color = vec4(vec3(metallic), pos.a);\n    return;\n    #endif\n    \n    #ifdef SHOW_ROUGHNESS\n    color = vec4(vec3(roughness), pos.a);\n    return;\n    #endif\n\n    #ifdef SHADOWMAP_ENABLED\n    #ifdef SHOW_SHADOWMAP\n    // color = vec4(vec3(eye_space_z(texture(u_shadowmapTx, tx_pos).r, u_lightNear, u_lightFar)), 1.);\n    color = vec4(vec3(texture(u_shadowmapTx, tx_pos).r), 1.);\n    return;\n    #endif\n    #endif\n\n    color = vec4(.5, .0, .0, 1.);\n    return;\n}\n"),ln={Rn:(new kt).Un(rn).Un(an).Un(on).Un("\nlayout(location = 0) out vec4 color;\n\n#define SHADOW_MAP_ERROR 0.99\n\nuniform sampler2D u_ssaoTx;\nuniform sampler2D u_shadowmapTx;\n\nuniform mat4 u_cameraViewSpaceToLightCamera;\n\nuniform float u_shadowMapFixedBias;\nuniform float u_shadowMapNormalBias;\nuniform float u_lightNear;\nuniform float u_lightFar;\n\nstruct light {\n    #ifdef DIRECTIONAL_LIGHT\n    vec3 direction;\n    #endif\n    \n    #ifdef POINT_LIGHT\n    float radius;\n    float attenuation;\n    vec3 position;\n    #endif\n    \n    vec3 color;\n    float intensity;\n};\n\nuniform vec3[3] u_lightData;\n\nlight makeLight() {\n    light l;\n    \n    #ifdef DIRECTIONAL_LIGHT\n    l.direction = (u_worldToCameraMatrix * vec4(u_lightData[0], 0.)).xyz;\n    #endif\n    \n    #ifdef POINT_LIGHT\n    l.position = (u_worldToCameraMatrix * vec4(u_lightData[0], 1.)).xyz;\n    l.radius = u_lightData[2].y;\n    l.attenuation = u_lightData[2].z;\n    #endif\n    \n    l.color = u_lightData[1];\n    l.intensity = u_lightData[2].x;\n    \n    return l;\n}\n").Un("\nconst float PI = 3.14159265359;\n\n// https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nfloat UE4Falloff(float distance, float lightRadius) {\n    float nominator = clamp(1. - pow(distance / lightRadius, 4.), 0., 1.); \n    return nominator * nominator / (distance * distance + 1.);\n}\n\nfloat UE4NDF(float NdotH, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float roughness) {\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float HdotV, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n}  \n\nvec3 fresnelSchlick(vec3 albedo, float metallic, float HdotV) {\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n\n    return fresnelSchlick(HdotV, F0);\n}\n\nvec3 CookTorranceBRDF(\n    vec3 albedo, float roughness, float metallic, \n    vec3 V, vec3 normal, vec3 L, vec3 radiance\n) {\n    vec3 H = normalize(V + L);\n    vec3 N = normal;\n    \n    float NdotL = max(dot(N, L), 0.);\n    float NdotH = max(dot(N, H), 0.);\n    float NdotV = max(dot(N, V), 0.);\n    float HdotV = max(dot(H, V), 0.);\n\n    float NDF = UE4NDF(NdotH, roughness);\n    // return NDF * radiance * NdotL;\n    \n    float G = GeometrySmith(NdotV, NdotL, roughness);      \n    vec3 F = fresnelSchlick(albedo, metallic, HdotV);       \n    \n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - metallic;\t  \n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * NdotV * NdotL;\n    vec3 specular     = numerator / max(denominator, 0.001);\n        \n    // add to outgoing radiance Lo\n    return (kD * albedo.xyz / PI + specular) * radiance * NdotL; \n}\n\nvec3 toneMap(vec3 color) {\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    return color; \n}\n\n").kn("\nvoid main() {\n    vec4 normal = GBUFFER_NORMAL(tx_pos);\n    vec4 pos = GBUFFER_POSITION(tx_pos);\n    vec4 albedo = GBUFFER_ALBEDO(tx_pos);\n\n    float metallic;\n    float roughness;\n    GBUFFER_MR(tx_pos, metallic, roughness);\n\n    // final color.\n    vec3 c = vec3(0.);\n\n    light l = makeLight();\n    \n    #ifdef POINT_LIGHT\n    vec3 lightDir = normalize(pos.xyz - l.position);\n    float distanceForAttenuation = length(l.position - pos.xyz);\n    float attenuation = UE4Falloff(distanceForAttenuation, l.radius);\n    \n    // color = vec4(1.);\n    // return;\n    #endif\n    \n    #ifdef DIRECTIONAL_LIGHT\n    vec3 lightDir = l.direction;\n    float attenuation = 1.;\n    #endif\n    \n    #ifdef SSAO_ENABLED\n    float ssao = texture(u_ssaoTx, tx_pos).r;\n    #else\n    float ssao = 1.0;\n    #endif\n    \n    //ambient\n    vec3 ambient = vec3(AMBIENT_CONSTANT_HACK) * albedo.rgb * l.color * ssao * attenuation * l.intensity;\n    c += ambient;\n\n    #ifdef SHADOWMAP_ENABLED\n    float bias = u_shadowMapFixedBias + u_shadowMapNormalBias * (1.0 - abs(dot(normal.xyz, -lightDir)));\n\n    vec4 posLSS = u_cameraViewSpaceToLightCamera * pos;\n    posLSS.xyz /= posLSS.w;\n    \n    // color = posLSS;\n    // return;\n\n    vec2 texmapscale = vec2(1. / SHADOW_MAP_WIDTH, 1. / SHADOW_MAP_HEIGHT);\n\n    int notInShadowSamples = 0;\n    float x, y;\n    float shadowMapDepth;\n    vec2 base = posLSS.xy * 0.5 + 0.5;\n\n    for (y = -1.5; y <= 1.5; y += 1.0) {\n        for (x = -1.5; x <= 1.5; x += 1.0) {\n            vec2 offset = base + vec2(x, y) * texmapscale;\n            \n            // the depth buffer texture is clamped to 0, 1, so unclamp.\n            shadowMapDepth = texture(u_shadowmapTx, offset).r * 2. - 1.;\n            \n            // out of bounds by X or Y\n            if (offset.x < 0. || offset.y < 0. || offset.x > 1. || offset.y > 1.) {\n                notInShadowSamples++;\n                continue;\n            }\n            \n            // out of bounds by Z case\n            if (abs(posLSS.z) > 1.) {\n                // if out of bounds by Z, then it's in shadow if there's anything else in view (i.e. there's depth)\n                if (abs(shadowMapDepth) < SHADOW_MAP_ERROR) {\n                    continue;\n                }\n                notInShadowSamples++;\n                continue;\n            } else if (shadowMapDepth > posLSS.z - bias) {\n                notInShadowSamples++;\n            }\n        }\n    }\n    l.intensity *= float(notInShadowSamples) / 16.0;\n    #endif\n    \n    // calculate per-light radiance\n    vec3 radiance = l.color * attenuation * l.intensity;\n    \n    c += CookTorranceBRDF(\n        albedo.xyz, roughness, metallic, \n        -normalize(pos.xyz), normal.xyz, -lightDir, radiance\n    );\n\n    c = toneMap(c);\n\n    color = vec4(c.xyz, 1.);\n}\n"),Fe:hn,Oe:(new kt).Un(an).kn("\nlayout(location = 0) in vec4 a_pos;\nout vec2 tx_pos;\n\nvoid main() {\n    gl_Position = u_perspectiveMatrix * u_modelViewMatrix * a_pos;\n    gl_Position /= gl_Position.w;\n    tx_pos = (gl_Position.xy / gl_Position.w) / 2. + 0.5;\n}\n")},un={ot:"\nprecision highp float;\n\nlayout(location = 0) in vec4 a_pos;\nlayout(location = 1) in vec3 a_norm;\nlayout(location = 2) in vec2 a_uv;\nlayout(location = 3) in vec4 a_tangent;\n\nuniform mat4 u_modelViewMatrix;\nuniform mat4 u_modelWorldMatrix;\nuniform mat4 u_worldToCameraMatrix;\nuniform mat4 u_perspectiveMatrix;\n\nout vec4 v_pos;\nout vec4 v_norm;\nout vec2 v_uv;\nout vec4 v_tangent;\n\nvoid main() {\n    v_pos = u_modelViewMatrix * a_pos;\n    gl_Position = u_perspectiveMatrix * u_modelViewMatrix * a_pos;\n\n    v_norm = normalize(u_modelViewMatrix * vec4(a_norm, 0.));\n    v_uv = a_uv;\n    v_tangent = a_tangent;\n    gl_PointSize = 2.;    \n}\n",Rn:"\nprecision highp float;\n\nin vec4 v_pos;\nin vec4 v_norm;\nin vec4 v_tangent;\nin vec2 v_uv;\n\nuniform mat4 u_modelViewMatrix;\nuniform vec4 u_albedo;\nuniform vec4 u_albedoFactor;\nuniform bool u_albedoHasFactor;\nuniform bool u_albedoHasTexture;\nuniform sampler2D u_albedoTexture;\n\nuniform float u_metallic;\nuniform bool u_metallicHasTexture;\nuniform sampler2D u_metallicTexture;\n\nuniform float u_roughness;\nuniform bool u_roughnessHasTexture;\nuniform sampler2D u_roughnessTexture;\n\nuniform bool u_normalMapHasTexture;\nuniform bool u_hasTangent;\nuniform sampler2D u_normalMapTx;\n\nlayout(location = 0) out vec4 gbuf_position;\nlayout(location = 1) out vec3 gbuf_normal;\nlayout(location = 2) out vec4 gbuf_albedo;\nlayout(location = 3) out vec4 gbuf_metallic_roughness;\n\nvec4 srgb(vec4 color) {\n    return vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\n\nvoid main() {\n    gbuf_position = vec4(v_pos.xyz, 1.0);\n    vec3 normal;\n    if (u_normalMapHasTexture && u_hasTangent) {\n        vec3 normalMap = normalize(texture(u_normalMapTx, v_uv).xyz * 2. - 1.);\n        vec3 tangent = normalize(u_modelViewMatrix * vec4(v_tangent.xyz, 0.)).xyz;\n        vec3 bitangent = cross(v_norm.xyz, tangent) * v_tangent.w;\n        mat3 tangentToView = mat3(\n            tangent,\n            bitangent,\n            v_norm.xyz\n        );\n        normal = normalize(tangentToView * normalMap);\n    } else {\n        normal = normalize(v_norm.xyz);\n    }\n    // encode Z normal sign in R. This is pretty stupid encoding but does the job.\n    if (normal.z < 0.) {\n        normal.x += 3.;\n    }\n    gbuf_normal = normal;\n    \n    if (u_albedoHasTexture) {\n        gbuf_albedo = srgb(texture(u_albedoTexture, v_uv));\n        if (u_albedoHasFactor) {\n           gbuf_albedo *= u_albedoFactor;\n        }\n    } else {\n        gbuf_albedo = u_albedo;\n    }\n\n    if (gbuf_albedo.a == 0.) {\n        discard;\n        return;\n    }\n    \n    float metallic;\n    float roughness;\n    \n    if (u_metallicHasTexture) {\n        metallic = texture(u_metallicTexture, v_uv).b;\n    } else {\n        metallic = u_metallic;\n    }\n    \n    if (u_roughnessHasTexture) {\n        roughness = texture(u_roughnessTexture, v_uv).g;\n    } else {\n        roughness = u_roughness;\n    }\n    \n    gbuf_metallic_roughness = vec4(metallic, roughness, 1., 1.);\n}\n"},cn={Re:(new kt).Bn("lowp").Un(on).Un(an).Un(rn).kn("\nlayout(location = 0) out vec4 color;\n\nuniform float u_ssaoRadius;\nuniform float u_ssaoBias;\nuniform sampler2D u_ssaoNoise;\nuniform vec2 u_ssaoNoiseScale;\nuniform vec3[SSAO_SAMPLES] u_ssaoSamples;\n\nfloat ssao(vec3 normalVS, vec4 posVS, vec2 tx_pos) {\n    vec3 random = normalize(texture(u_ssaoNoise, tx_pos * u_ssaoNoiseScale).xyz);\n    vec3 tangent = normalize(random - normalVS * dot(normalVS, random));\n    vec3 bitangent = cross(normalVS, tangent);\n    \n    mat3 tangentToViewSpaceMatrix = mat3(tangent, bitangent, normalVS);\n\n    // return vec4(normal, 1.);\n    // return vec4(tangentToViewSpaceMatrix * normalVS, 1.);\n\n    float radius = u_ssaoRadius;\n    float samples = float(SSAO_SAMPLES);\n    float occlusion = 0.;\n    float totalWeight = 0.;\n    float bias = u_ssaoBias;\n\n    for (int i = 0; i < SSAO_SAMPLES; i++) {\n        vec4 randomVectorVS = vec4(tangentToViewSpaceMatrix * u_ssaoSamples[i], 0.);\n        // vec4 randomVectorVS = vec4(tangentToViewSpaceMatrix * vec3(0., 0., 1.), 0.);\n\n        // Sample in view space.\n        vec4 sampleVS = posVS + randomVectorVS * radius;\n\n        vec4 sampleSS = u_perspectiveMatrix * sampleVS;\n        sampleSS /= sampleSS.w;\n        \n        float weight = dot(randomVectorVS.xyz, normalVS.xyz);\n        totalWeight += weight;\n\n        vec2 absSampleSS = abs(sampleSS.xy);\n        if (absSampleSS.x >= 1. || absSampleSS.y >= 1.) {\n            continue;\n        }\n        \n        vec4 storedPosVS = GBUFFER_POSITION(sampleSS.xy * 0.5 + 0.5);\n        float storedDepthVS = storedPosVS.z;\n\n        if (storedDepthVS > sampleVS.z + bias) {\n            float falloff = smoothstep(0.0, 1.0, radius / length(storedPosVS.xyz - posVS.xyz));\n            // float falloff = 1. - smoothstep(0.8, 1.2, length(storedPosVS.xyz - posVS.xyz) / radius);\n            occlusion += falloff * weight;\n        }\n    }\n    occlusion = 1. - (occlusion / totalWeight);\n    return occlusion;\n}\n\nvoid main() {\n    vec3 normal = GBUFFER_NORMAL(tx_pos).xyz;\n    vec4 pos = GBUFFER_POSITION(tx_pos);\n\n    float occlusion = ssao(normal, pos, tx_pos);\n    color = vec4(vec3(occlusion), pos.a);\n}\n"),Pe:(new kt).Un(on).Un(rn).Un(an).kn('\nlayout(location = 0) out vec4 color;\n\nuniform sampler2D u_ssaoFirstPassTx;\nuniform float u_ssaoStrength;\nuniform float u_ssaoBlurPositionThreshold;\nuniform float u_ssaoBlurNormalThreshold;\n\n// This does position and normal-aware "smart-blur".\nfloat getSsaoBlurred(vec4 posVS, vec3 normalVS) {\n    vec2 texelSize = vec2(1. / float(SSAO_TEXEL_SIZE_X), 1. / float(SSAO_TEXEL_SIZE_Y));\n    \n    if (posVS.a == 0.) {\n        return 1.;\n    }\n\n    int samples = 1;\n    float occlusion = texture(u_ssaoFirstPassTx, tx_pos).r;\n    // return occlusion;\n    \n    for (int i = -SSAO_NOISE_SCALE / 2; i < SSAO_NOISE_SCALE / 2; i++) {\n        for (int j = -SSAO_NOISE_SCALE / 2; j < SSAO_NOISE_SCALE / 2; j++) {\n            if (i == 0 && j == 0) {\n                continue;\n            }\n\n            vec2 offset = tx_pos + texelSize * vec2(float(i), float(j));\n            \n            vec4 posVS_offset = GBUFFER_POSITION(offset);\n            if (posVS_offset.a == 0.) {\n                continue;\n            }\n            \n            if (abs(posVS.z - posVS_offset.z) > u_ssaoBlurPositionThreshold) {\n                continue;\n            }\n            \n            vec3 normalVS_offset = GBUFFER_NORMAL(offset).xyz;\n            if (abs(dot(normalVS_offset, normalVS)) < u_ssaoBlurNormalThreshold) {\n                continue;\n            }\n            \n            occlusion += texture(u_ssaoFirstPassTx, offset).r;\n            samples += 1;\n        }\n    }\n\n    occlusion /= float(samples);\n    \n    return pow(occlusion, u_ssaoStrength);\n}\n\nvoid main() {\n    vec3 normalVS = GBUFFER_NORMAL(tx_pos).xyz;\n    vec4 posVS = GBUFFER_POSITION(tx_pos);\n    \n    color = vec4(getSsaoBlurred(posVS, normalVS), 0., 0., 1.);\n    // color = vec4(texture(u_ssaoFirstPassTx, tx_pos).xyz, 1.);\n}\n')},fn={ot:(new kt).Un(an).kn("\nlayout(location = 0) in vec4 a_pos;\nout vec4 v_pos;\nout vec2 tx_pos;\n\nvoid main() {\n    v_pos = u_modelViewMatrix * a_pos;\n    gl_Position = u_perspectiveMatrix * v_pos;\n    tx_pos = (gl_Position.xy / gl_Position.w) / 2. + 0.5;\n}\n"),Le:(new kt).Un(an).kn("\nin vec4 v_pos;\nin vec2 tx_pos;\n\nuniform vec3 u_color;\nuniform float u_intensity;\nuniform sampler2D u_posTexture;\n\nout vec4 color;\n\nvoid main() {\n    float alpha = 1.0;\n    vec4 sceneTexel = texture(u_posTexture, tx_pos);\n    vec4 scenePos = sceneTexel;\n    if (scenePos.z > v_pos.z && sceneTexel.a > 0.) {\n        alpha = 0.;\n    }\n    color = vec4(u_color * u_intensity, alpha);\n}\n")};class mn{constructor(){this.enabled=!0,this.Ce=32,this.Ve=2,this.Ie=2,this._t=.75,this.bias=.025,this.strength=1,this.De=.3,this.He=.9}isEnabled(){return this.enabled&&this.strength>0}Be(){return Object.assign(new mn,this)}}class dn{constructor(t,n){this.Ge(t,n)}Ge(t,n){this.delete(t),this.ze=n.Be();const e=new Array;for(let t=0;t<n.Ce;t++){const s=J(Math.pow(t/n.Ce,n.Ie),0,1,.1,1);e.push(Q(-1,1)*s),e.push(Q(-1,1)*s),e.push(Q(0,1)*s)}this.We=new Float32Array(e);const s=[];for(let t=0;t<n.Ve*n.Ve;t++)s.push(Q(-1,1)),s.push(Q(-1,1)),s.push(0);const i=new Float32Array(s);return this.ke=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.ke),t.texImage2D(t.TEXTURE_2D,0,t.RGB16F,n.Ve,n.Ve,0,t.RGB,t.FLOAT,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this}delete(t){this.ke&&t.deleteTexture(this.ke)}}const pn={ot:(new kt).Un(an).kn("\nlayout(location = 0) in vec4 a_pos;\nout vec4 v_pos;\n\nuniform mat4 u_lightCameraWorldToProjectionMatrix;\n\nvoid main() {\n    v_pos = u_lightCameraWorldToProjectionMatrix * u_modelWorldMatrix * a_pos;\n    gl_Position = v_pos;\n}\n"),Rn:(new kt).kn("\nvoid main() {\n}\n")};class _n{constructor(t,n,e){this.Ue=null,this.value=t,this.je=e,n&&(this.Ue=n)}$e(t){return this.value=t,this}Xe(t){return this.je=t,this}Ze(){return!!this.Ue}Ye(){return void 0!==this.je&&null!==this.je}qe(t){return this.Ue=t,this}}class Sn{constructor(t,n,e){this.Ke=new _n(x(1,1,1,1)),this.Je=new _n(0),this.Qe=new _n(.5),this.ts=!1,t&&b(this.Ke.value,t),void 0!==n&&(this.Je.value=n),void 0!==e&&(this.Qe.value=e)}ns(t,n,e,s){return this.Ke.value[0]=t,this.Ke.value[1]=n,this.Ke.value[2]=e,this.Ke.value[3]=s,this}es(t){return this.Je.$e(t),this}ss(t){return this.Qe.$e(t),this}os(t){return this.ts=t,this}rs(t){return this.as=t,this}}const gn={Rn:(new kt).kn(rn).kn(an).kn(on).kn("\nout vec4 color;\nuniform sampler2D u_lightedSceneTx;\n\nvoid main() {\n    vec3 eye = vec3(0., 0., 0.);\n    vec4 posVS = GBUFFER_POSITION(tx_pos);\n    vec4 normalVS = GBUFFER_NORMAL(tx_pos);\n    \n    float metallic;\n    float roughness;\n    GBUFFER_MR(tx_pos, metallic, roughness);\n    \n    vec3 reflectRay = reflect(normalize(posVS.xyz - eye), normalVS.xyz);\n\n    // float strength = (1. - roughness) * metallic;\n    float strength = (1. - roughness);\n    // float strength = 1.; // this is good for testing SSR or just displaying it.\n    if (strength < 0.01) {\n        color = vec4(vec3(0.), 0.);\n        return;\n    }\n    \n    vec3 c = vec3(0.);\n    \n    int i = 0;\n\n    bool isFound = false;\n    \n    for (; i < SSR_STEPS; i++) {\n        vec3 sampleVS = posVS.xyz + reflectRay * (SSR_STEP_SIZE * float(i + 1));\n        vec4 sampleSS4 = u_perspectiveMatrix * vec4(sampleVS, 1.);\n        vec3 sampleSS = sampleSS4.xyz / sampleSS4.w;\n        \n        // ignore off-screen samples\n        if (abs(sampleSS.x) > 1. || abs(sampleSS.y) > 1.) {\n            break;\n        } \n        \n        vec4 resultVS = GBUFFER_POSITION(sampleSS.xy * 0.5 + 0.5);\n        \n        // The ray intersected smth, do binary search\n        float distance = resultVS.z - sampleVS.z;\n        float minDistance = abs(distance);\n        vec3 minPosSS = sampleSS;\n        \n        if (distance > 0. && resultVS.a > 0.) {\n            vec3 dir = reflectRay * (SSR_STEP_SIZE * 0.5);\n            for (int j = 0; j < SSR_BINARY_SEARCH_STEPS; ++j) {\n                if (distance > 0.) {\n                    sampleVS -= dir;\n                } else {\n                    sampleVS += dir;\n                }\n                dir *= 0.5;\n                \n                sampleSS4 = u_perspectiveMatrix * vec4(sampleVS, 1.);\n                sampleSS = sampleSS4.xyz / sampleSS4.w;\n                \n                resultVS = GBUFFER_POSITION(sampleSS.xy * 0.5 + 0.5);\n                \n                // hit out-of-bounds somewhere.\n                if (resultVS.a == 0.) {\n                    continue;\n                }\n                \n                distance = resultVS.z - sampleVS.z;\n                if (abs(distance) < minDistance) {\n                    minDistance = abs(distance);\n                    minPosSS = sampleSS;\n                }\n            }\n            \n            // c = vec3(distance);\n            if (abs(minDistance) < 0.05) {\n                float howFar = clamp(length(sampleVS - posVS.xyz) / (float(SSR_STEPS) * SSR_STEP_SIZE), 0., 1.);\n                // the further the sample is from the start and the closer it is to screen edges, the more is attenuation.\n                float attenuation = (1. - howFar) * (1. - smoothstep(.7, .95, abs(sampleSS.x))) * (1. - smoothstep(.7, .95, abs(sampleSS.y)));\n                strength *= attenuation;\n                c = texture(u_lightedSceneTx, minPosSS.xy * 0.5 + 0.5).xyz;\n                isFound = true;\n            }\n            break;\n        }\n    }\n\n    if (!isFound) {\n        strength = 0.;\n    }\n\n    color = vec4(c, strength);\n}\n")};class vn{constructor(){this.hs=.001,this.ls=.001}}class wn{}class xn{constructor(){this.us=bn.Final,this.cs=!0,this.fs=!0,this.ms=new mn,this.ds=new vn,this.ps=new wn}_s(...t){return Tn(this.us,...t)}}var bn;!function(t){t[t.Final=1]="Final",t[t.Positions=2]="Positions",t[t.Normals=3]="Normals",t[t.Color=4]="Color",t[t.SSAO=5]="SSAO",t[t.SSR=6]="SSR",t[t.ShadowMap=7]="ShadowMap",t[t.Metallic=8]="Metallic",t[t.Roughness=9]="Roughness"}(bn||(bn={}));const Tn=(t,...n)=>{for(let e=0;e<n.length;e++)if(t===n[e])return!0};var Mn,En;function yn(t,n,e,s,i){t.activeTexture(t.TEXTURE0+i),t.bindTexture(t.TEXTURE_2D,s),t.uniform1i(n.getUniformLocation(t,e),i)}function An(t,n,e,s,i,o,r){i=i||t.canvas.width,o=o||t.canvas.height,r=r||t.NEAREST;let a=t.createTexture();return t.bindTexture(t.TEXTURE_2D,a),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,r),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,r),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,n,i,o,0,e,s,null),a}function Nn(t,n,e,s){let i=!1;t.canvas.width==n&&t.canvas.height==e||(t.viewport(0,0,n,e),i=!0);const o=s();return i&&t.viewport(0,0,t.canvas.width,t.canvas.height),o}!function(t){t[t.NORMAL=1]="NORMAL",t[t.SSR=2]="SSR"}(Mn||(Mn={})),function(t){t[t.TEMP=128]="TEMP"}(En||(En={}));class Fn{constructor(t,n){this.Ss=new Sn,this.gs=WebGL2RenderingContext.COLOR_ATTACHMENT0,this.vs=WebGL2RenderingContext.COLOR_ATTACHMENT0+1,this.ws=WebGL2RenderingContext.COLOR_ATTACHMENT0+2,this.xs=WebGL2RenderingContext.COLOR_ATTACHMENT0+3,this.bs=n,this.Ts(t),this.compileShader(t)}Kn(t,n,e){t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.Ms),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT|t.STENCIL_BUFFER_BIT),t.enable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.enable(t.STENCIL_TEST),t.stencilMask(15);const s=this.Es;s.Pn(t),t.uniform3fv(s.getUniformLocation(t,O),n.position),t.uniformMatrix4fv(s.getUniformLocation(t,R),!1,n.K()),t.uniformMatrix4fv(s.getUniformLocation(t,L),!1,n.et().matrix),t.drawBuffers([this.gs,this.vs,this.ws,this.xs]),t.disable(t.BLEND);for(let s=0;s<e.children.length;s++)this.ys(t,e.children[s],n);t.disable(t.STENCIL_TEST)}As(t,n,e,s,i){const o=this.Es,r=n,a=n+"HasTexture",h=n+"Texture",l=n+"HasFactor",u=n+"Factor";t[s](o.getUniformLocation(t,r),e.value);let c=e.Ze();"u_albedo"!=n||this.bs.fs||(c=!1),t.uniform1i(o.getUniformLocation(t,a),c?1:0),c&&yn(t,o,h,e.Ue.Ns(),i);const f=e.Ye();t.uniform1i(o.getUniformLocation(t,l),f?1:0),f&&t[s](o.getUniformLocation(t,u),e.je)}ys(t,n,e){const s=this.Es;if(null!=n.mesh){const i=n.transform.ut(),o=it,r=n.material?n.material.material:this.Ss;j(o,e.K(),i),t.uniformMatrix4fv(s.getUniformLocation(t,V),!1,o),t.uniformMatrix4fv(s.getUniformLocation(t,C),!1,i),this.As(t,"u_albedo",r.Ke,"uniform4fv",1),this.As(t,"u_metallic",r.Je,"uniform1f",2),this.As(t,"u_roughness",r.Qe,"uniform1f",3);const a=!!r.as&&this.bs.cs;t.uniform1i(s.getUniformLocation(t,"u_normalMapHasTexture"),a?1:0),a&&yn(t,s,"u_normalMapTx",r.as.Ns(),4),t.uniform1i(s.getUniformLocation(t,G),n.mesh.primitives[0].sn()?1:0);let h=Mn.NORMAL;if(r.ts&&(h=Mn.SSR),t.stencilFunc(t.ALWAYS,h,255),t.stencilOp(t.KEEP,t.KEEP,t.REPLACE),n.mesh.en(t),n.ht&&n.ht.visible){n.ht.oe(t).en(t)}}for(let s=0;s<n.children.length;s++)this.ys(t,n.children[s],e)}compileShader(t){this.Es=new Gt(t,new Wt(t,un.ot),new zt(t,un.Rn))}Ts(t){this.Fs=An(t,t.RGBA,t.RGBA,t.UNSIGNED_BYTE),this.Os=An(t,t.RG16F,t.RG,t.HALF_FLOAT),this.Rs=An(t,t.RG32F,t.RG,t.FLOAT),this.Ps=An(t,t.RGBA16F,t.RGBA,t.FLOAT),this.Ls=An(t,t.DEPTH24_STENCIL8,t.DEPTH_STENCIL,t.UNSIGNED_INT_24_8),this.Ms=t.createFramebuffer(),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.Ms),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,this.gs,t.TEXTURE_2D,this.Ps,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,this.vs,t.TEXTURE_2D,this.Rs,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,this.ws,t.TEXTURE_2D,this.Fs,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,this.xs,t.TEXTURE_2D,this.Os,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,this.Ls,0),Dn(t)}}class On{constructor(t,n,e,s,i){this.Cs=e,this.Vs=s,this.Is=i,this.width=t.canvas.width,this.height=t.canvas.height,this.Ds(t,n),this.Hs(t)}get Bs(){return this.Gs}zs(t){this.Hs(t)}Hs(t){[this.Ws,this.ks].forEach(n=>{n&&n.Cn(t)}),this.Ws=new Gt(t,this.Is.Us,new zt(t,cn.Re.clone().zn("SSAO_SAMPLES",this.Cs.Ce.toString()).$n())),this.Ws.Pn(t),this.ks=new Gt(t,this.Is.Us,new zt(t,cn.Pe.clone().zn("SSAO_NOISE_SCALE",this.Cs.Ve.toString()).zn("SSAO_TEXEL_SIZE_X",this.width.toString()).zn("SSAO_TEXEL_SIZE_Y",this.height.toString()).$n())),this.ks.Pn(t)}Kn(t,n){(()=>{const e=this.Ws;e.Pn(t),t.bindFramebuffer(t.FRAMEBUFFER,this.js),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),this.Is.bind(t),t.uniformMatrix4fv(e.getUniformLocation(t,R),!1,n.K()),t.uniformMatrix4fv(e.getUniformLocation(t,L),!1,n.et().matrix),t.uniform1f(e.getUniformLocation(t,"u_ssaoRadius"),this.Cs._t),t.uniform1f(e.getUniformLocation(t,"u_ssaoBias"),this.Cs.bias),t.uniform3fv(e.getUniformLocation(t,"u_ssaoSamples"),this.$s.We),t.uniform2fv(e.getUniformLocation(t,"u_ssaoNoiseScale"),[this.width/this.Cs.Ve,this.height/this.Cs.Ve]),yn(t,this.Ws,I,this.Vs.Ps,0),yn(t,this.Ws,D,this.Vs.Rs,1),yn(t,this.Ws,"u_ssaoNoise",this.$s.ke,2),Nn(t,this.width,this.height,()=>{this.Is.en(t)})})(),(()=>{const e=this.ks;e.Pn(t),t.bindFramebuffer(t.FRAMEBUFFER,this.Xs),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),this.Is.bind(t),t.uniformMatrix4fv(e.getUniformLocation(t,R),!1,n.K()),t.uniformMatrix4fv(e.getUniformLocation(t,L),!1,n.et().matrix),t.uniform1f(e.getUniformLocation(t,"u_ssaoStrength"),this.Cs.strength),t.uniform1f(e.getUniformLocation(t,"u_ssaoBias"),this.Cs.bias),t.uniform1f(e.getUniformLocation(t,"u_ssaoBlurPositionThreshold"),this.Cs.De),t.uniform1f(e.getUniformLocation(t,"u_ssaoBlurNormalThreshold"),this.Cs.He),t.uniform3fv(e.getUniformLocation(t,"u_ssaoSamples"),this.$s.We),t.uniform2fv(e.getUniformLocation(t,"u_ssaoNoiseScale"),[t.canvas.width/this.Cs.Ve,t.canvas.height/this.Cs.Ve]),yn(t,this.ks,I,this.Vs.Ps,0),yn(t,this.ks,D,this.Vs.Rs,1),yn(t,this.ks,"u_ssaoNoise",this.$s.ke,2),yn(t,this.ks,"u_ssaoFirstPassTx",this.Zs,3),this.Is.en(t)})()}Ds(t,n){this.$s=n,this.js=t.createFramebuffer(),this.Zs=An(t,t.R16F,t.RED,t.HALF_FLOAT,this.width,this.height),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.js),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.Zs,0),Dn(t),this.Xs=t.createFramebuffer(),this.Gs=An(t,t.R16F,t.RED,t.HALF_FLOAT),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.Xs),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.Gs,0),Dn(t)}}class Rn{constructor(t){this.Ys(t),this.Hs(t)}get qs(){return this.Ks}get Js(){return this.Qs}get ti(){return this.ni}Kn(t,n,e){t.enable(t.DEPTH_TEST),t.enable(t.CULL_FACE);const s=this.ei;t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.si),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),s.Pn(t),t.uniformMatrix4fv(s.getUniformLocation(t,"u_lightCameraWorldToProjectionMatrix"),!1,n.matrix);const i=n=>{n.children.forEach(i),n.mesh&&(n.mesh.gt||n.mesh.Qn)&&(t.uniformMatrix4fv(s.getUniformLocation(t,C),!1,n.transform.ut()),n.mesh.en(t))};Nn(t,this.Qs,this.ni,()=>{e.children.forEach(i)})}Hs(t){this.ei=new Gt(t,new Wt(t,pn.ot.$n()),new zt(t,pn.Rn.$n()))}Ys(t){this.Qs=2048,this.ni=2048,this.Ks=An(t,t.DEPTH_COMPONENT16,t.DEPTH_COMPONENT,t.UNSIGNED_SHORT,this.Qs,this.ni,t.NEAREST),this.si=t.createFramebuffer(),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.si),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,this.Ks,0),Dn(t)}}class Pn{constructor(t,n,e,s,i,o,r){this.ii=null,this.oi=null,this.ri=null,this.ai=!0,this.Is=e,this.Vs=s,this.hi=i,this.li=o,this.ui=new nn("sphere").Te(new Xt(r)).$n(),this.bs=n,this.ci=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.ci),this.fi=An(t,t.RGBA,t.RGBA,t.UNSIGNED_BYTE),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.fi,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,this.Vs.Ls,0),Dn(t),this.mi=new Gt(t,new Wt(t,fn.ot.$n()),new zt(t,fn.Le.$n())),this.di()}di(){this.ai=!0}Hs(t){[this.ii,this.ri,this.oi].forEach(n=>{n&&n.Cn(t)}),this.ii=new Gt(t,this.Is.Us,new zt(t,ln.Fe.clone().zn("SCREEN_WIDTH",t.canvas.width.toString()).zn("SCREEN_HEIGHT",t.canvas.height.toString()).zn("SHADOW_MAP_WIDTH",`${this.li.Js}.`).zn("SHADOW_MAP_HEIGHT",`${this.li.ti}.`).Gn("SSAO_ENABLED",this.bs.ms.isEnabled()).Gn("SHADOWMAP_ENABLED",this.bs.ds.enabled).Gn("SHOW_SSAO",this.bs.us===bn.SSAO).Gn("SHOW_COLORS",this.bs.us===bn.Color).Gn("SHOW_POSITIONS",this.bs.us===bn.Positions).Gn("SHOW_SHADOWMAP",this.bs.us===bn.ShadowMap).Gn("SHOW_NORMALS",this.bs.us===bn.Normals).Gn("SHOW_METALLIC",this.bs.us===bn.Metallic).Gn("SHOW_ROUGHNESS",this.bs.us===bn.Roughness).$n())),this.ii.Pn(t),this.oi=new Gt(t,this.Is.Us,new zt(t,ln.Rn.clone().zn("SCREEN_WIDTH",t.canvas.width.toString()).zn("SCREEN_HEIGHT",t.canvas.height.toString()).zn("SHADOW_MAP_WIDTH",`${this.li.Js}.`).zn("SHADOW_MAP_HEIGHT",`${this.li.ti}.`).zn("AMBIENT_CONSTANT_HACK","0.03").zn("DIRECTIONAL_LIGHT","").Gn("SSAO_ENABLED",this.bs.ms.isEnabled()).Gn("SHADOWMAP_ENABLED",this.bs.ds.enabled).$n())),this.oi.Pn(t),this.ri=new Gt(t,new Wt(t,ln.Oe.$n()),new zt(t,ln.Rn.clone().zn("SCREEN_WIDTH",t.canvas.width.toString()).zn("SCREEN_HEIGHT",t.canvas.height.toString()).zn("SHADOW_MAP_WIDTH",`${this.li.Js}.`).zn("SHADOW_MAP_HEIGHT",`${this.li.ti}.`).zn("AMBIENT_CONSTANT_HACK","0.03").zn("POINT_LIGHT","").Gn("SSAO_ENABLED",this.bs.ms.isEnabled()).$n())),this.ri.Pn(t),yn(t,this.ri,I,this.Vs.Ps,0),yn(t,this.ri,D,this.Vs.Rs,1),yn(t,this.ri,H,this.Vs.Fs,2),yn(t,this.ri,B,this.Vs.Os,3),yn(t,this.ri,"u_shadowmapTx",this.li.qs,4),yn(t,this.ri,"u_ssaoTx",this.hi.Bs,5),this.ai=!1}Kn(t,n,e){if(this.ai&&this.Hs(t),t.bindFramebuffer(t.FRAMEBUFFER,this.ci),t.disable(t.DEPTH_TEST),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT),!this.bs._s(bn.Final,bn.SSR)){this.bs.us===bn.ShadowMap&&(this.li.Kn(t,dt(n.Ne[0],e,n,mt),n),t.bindFramebuffer(t.FRAMEBUFFER,this.ci));this.ii.Pn(t);return yn(t,this.ii,I,this.Vs.Ps,0),yn(t,this.ii,D,this.Vs.Rs,1),yn(t,this.ii,H,this.Vs.Fs,2),yn(t,this.ii,B,this.Vs.Os,3),yn(t,this.ii,"u_shadowmapTx",this.li.qs,4),yn(t,this.ii,"u_ssaoTx",this.hi.Bs,5),void this.Is.en(t)}t.enable(t.STENCIL_TEST);t.stencilFunc(t.EQUAL,Mn.NORMAL,15),t.stencilMask(0),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),n.Ne.forEach((s,i)=>{let o=null;this.bs.ds.enabled&&(o=dt(s,e,n,mt),t.disable(t.STENCIL_TEST),this.li.Kn(t,o,n),t.disable(t.DEPTH_TEST),t.enable(t.STENCIL_TEST),t.bindFramebuffer(t.FRAMEBUFFER,this.ci)),t.enable(t.BLEND),t.blendEquationSeparate(t.FUNC_ADD,t.FUNC_ADD),t.blendFuncSeparate(t.ONE,t.ONE,t.ONE,t.ONE);let r=this.oi;if(r.Pn(t),t.uniform1f(r.getUniformLocation(t,"u_shadowMapFixedBias"),this.bs.ds.hs),t.uniform1f(r.getUniformLocation(t,"u_shadowMapNormalBias"),this.bs.ds.ls),t.uniform3fv(r.getUniformLocation(t,O),e.position),t.uniformMatrix4fv(r.getUniformLocation(t,R),!1,e.K()),t.uniformMatrix4fv(r.getUniformLocation(t,L),!1,e.et().matrix),t.uniformMatrix4fv(r.getUniformLocation(t,P),!1,e.tt()),this.bs.ds.enabled){const n=it;j(n,o.matrix,e.tt()),t.uniformMatrix4fv(r.getUniformLocation(t,"u_cameraViewSpaceToLightCamera"),!1,n),t.uniform1f(r.getUniformLocation(t,"u_lightNear"),o.near),t.uniform1f(r.getUniformLocation(t,"u_lightFar"),o.V)}t.uniform3fv(r.getUniformLocation(t,"u_lightData"),this.pi(s)),yn(t,r,I,this.Vs.Ps,0),yn(t,r,D,this.Vs.Rs,1),yn(t,r,H,this.Vs.Fs,2),yn(t,r,B,this.Vs.Os,3),yn(t,r,"u_shadowmapTx",this.li.qs,4),yn(t,r,"u_ssaoTx",this.hi.Bs,5),this.Is.en(t)});(()=>{const s=this.ri,i=new tn("sphere").transform,o=it;s.Pn(t),t.enable(t.BLEND),t.enable(t.DEPTH_TEST),t.enable(t.CULL_FACE),t.enable(t.STENCIL_TEST),t.stencilMask(En.TEMP),t.depthMask(!1),t.blendEquationSeparate(t.FUNC_ADD,t.FUNC_ADD),t.blendFuncSeparate(t.ONE,t.ONE,t.ONE,t.ONE),t.uniform1f(s.getUniformLocation(t,"u_shadowMapFixedBias"),this.bs.ds.hs),t.uniform1f(s.getUniformLocation(t,"u_shadowMapNormalBias"),this.bs.ds.ls),t.uniform3fv(s.getUniformLocation(t,O),e.position),t.uniformMatrix4fv(s.getUniformLocation(t,R),!1,e.K()),t.uniformMatrix4fv(s.getUniformLocation(t,L),!1,e.et().matrix),t.uniformMatrix4fv(s.getUniformLocation(t,P),!1,e.tt()),yn(t,s,I,this.Vs.Ps,0),yn(t,s,D,this.Vs.Rs,1),yn(t,s,H,this.Vs.Fs,2),yn(t,s,B,this.Vs.Os,3),yn(t,s,"u_shadowmapTx",this.li.qs,4),yn(t,s,"u_ssaoTx",this.hi.Bs,5),n.pt.forEach(n=>{t.uniform3fv(s.getUniformLocation(t,"u_lightData"),this._i(n));const h=2.1*n._t;i.scale=r(h,h,h),a(i.position,n.object.transform.position),i.update(),j(o,e.K(),i.ut()),t.uniformMatrix4fv(s.getUniformLocation(t,V),!1,o),t.uniformMatrix4fv(s.getUniformLocation(t,R),!1,e.K()),t.depthFunc(t.LEQUAL),t.cullFace(t.BACK),t.colorMask(!1,!1,!1,!1),t.stencilFunc(t.ALWAYS,En.TEMP,En.TEMP),t.stencilOp(t.KEEP,t.REPLACE,t.KEEP),this.ui.mesh.primitives[0].en(t),t.depthFunc(t.GEQUAL),t.cullFace(t.FRONT),t.colorMask(!0,!0,!0,!0),t.stencilFunc(t.EQUAL,Mn.NORMAL,15|En.TEMP),t.stencilOp(t.ZERO,t.ZERO,t.ZERO),this.ui.mesh.primitives[0].en(t)}),t.depthMask(!0),t.depthFunc(t.LEQUAL),t.disable(t.STENCIL_TEST),t.stencilMask(255),t.cullFace(t.BACK)})()}pi(t){let n=[];return n.push(...t.direction),n.push(...t.color),n.push(t.ae,0,0),new Float32Array(n)}_i(t){let n=[];return n.push(...t.object.transform.position),n.push(...t.color),n.push(t.ae,t._t,0),new Float32Array(n)}}class Ln{constructor(t,n,e,s,i){this.Is=i,this.ci=t.createFramebuffer(),this.Si=s,this.gi=e,t.bindFramebuffer(t.FRAMEBUFFER,this.ci),this.vi=An(t,t.RGBA,t.RGBA,t.UNSIGNED_BYTE),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.vi,0),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,e.Ls,0),Dn(t),this.Mn=new Gt(t,i.Us,new zt(t,gn.Rn.zn("SSR_STEPS","90").zn("SSR_STEP_SIZE","0.15").zn("SSR_BINARY_SEARCH_STEPS","10").$n())),this.wi=new Gt(t,i.Us,new zt(t,(new kt).Un(rn).kn("\n            uniform sampler2D u_lightedSceneTx;\n            uniform sampler2D u_ssrTx;\n            out vec4 color;\n            void main() {\n                vec4 l = texture(u_lightedSceneTx, tx_pos);\n                vec4 s = texture(u_ssrTx, tx_pos);\n                // color = vec4(max(l.rgb, s.rgb), l.a);\n                // color = vec4(mix(l.rgb, max(s.rgb * s.a, l.rgb), s.a), l.a);\n                color = vec4(mix(l.rgb, s.rgb, s.a), l.a);\n            }\n            ").$n()))}get fi(){return this.vi}Kn(t,n,e){t.bindFramebuffer(t.FRAMEBUFFER,this.ci),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.disable(t.DEPTH_TEST);const s=this.Mn;s.Pn(t),yn(t,s,"u_lightedSceneTx",this.Si.fi,0),yn(t,s,D,this.gi.Rs,1),yn(t,s,I,this.gi.Ps,2),yn(t,s,B,this.gi.Os,3),t.uniformMatrix4fv(s.getUniformLocation(t,R),!1,e.K()),t.uniformMatrix4fv(s.getUniformLocation(t,P),!1,e.tt()),t.uniformMatrix4fv(s.getUniformLocation(t,L),!1,e.et().matrix),this.Is.en(t)}xi(t,n){t.bindFramebuffer(t.FRAMEBUFFER,n);const e=this.wi;e.Pn(t),yn(t,e,"u_lightedSceneTx",this.Si.fi,0),yn(t,e,"u_ssrTx",this.fi,1),this.Is.en(t)}}class Cn{constructor(t,n){this.bi=new Gt(t,n.Us,new zt(t,(new kt).Un(rn).kn("\n            uniform sampler2D tx;\n            out vec4 color;\n            void main() {\n                color = texture(tx, tx_pos);\n            }\n            ").$n()))}get Mn(){return this.bi}}class Vn{constructor(t,n,e,s,i){this.Ti=n,this.Mi=e,this.Ei=i,this.Mn=s}Be(t){t.bindFramebuffer(t.FRAMEBUFFER,this.Mi);const n=this.Mn.Mn;n.Pn(t),yn(t,n,"tx",this.Ti,0),this.Ei.en(t)}}class In{constructor(t,n,e,s,i){this.di=!1,this.yi=t,this.Ai=n,this.gi=new Fn(t,n),this.hi=new On(t,i,this.Ai.ms,this.gi,e),this.ds=new Rn(t),this.Si=new Pn(t,this.bs,e,this.gi,this.hi,this.ds,s),this.ps=new Ln(t,this.bs,this.gi,this.Si,e);const o=new Cn(t,e);this.Ni=new Vn(t,this.Si.fi,null,o,e),this.Fi=new Vn(t,this.ps.fi,null,o,e)}get bs(){return this.Ai}zs(){this.hi.zs(this.yi),this.Si.di()}Hs(){this.di=!0}Kn(t,n){const e=this.yi;switch(this.di&&(this.hi.Hs(e),this.Si.di(),this.di=!1),this.gi.Kn(e,n,t),this.Ai.ms.isEnabled()&&this.hi.Kn(e,n),this.Si.Kn(e,t,n),this.bs.ps.enabled&&this.Ai._s(bn.Final,bn.SSR)&&this.ps.Kn(e,t,n),this.bs.ps.enabled){case!0:switch(this.bs.us){case bn.Final:e.disable(e.BLEND),this.ps.xi(e,null);break;case bn.SSR:e.bindFramebuffer(e.FRAMEBUFFER,null),e.enable(e.BLEND),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.blendFunc(e.SRC_ALPHA,e.ONE),this.Fi.Be(e);break;default:this.Ni.Be(e)}break;case!1:this.Ni.Be(e)}}}function Dn(t){const n=t.checkFramebufferStatus(t.DRAW_FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT");case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS");case t.FRAMEBUFFER_UNSUPPORTED:throw new Error("gl.FRAMEBUFFER_UNSUPPORTED");case t.Oi:throw new Error("gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE");case t.Ri:throw new Error("gl.RENDERBUFFER_SAMPLES");default:throw new Error("unknown error, but framebuffer is not complete. Error is "+n)}}const Hn=(()=>{let t=0;return()=>++t})(),Bn=t=>({className:t}),Gn=t=>{const n=function(){n.Pi&&n.Pi.apply(null,arguments)};return n.Pi=t,n},zn=(t,n,...e)=>{const s=document.createElement(t);if(n)for(const t in n){if(!n.hasOwnProperty(t))continue;const e=n[t];switch(t){case"for":s.setAttribute("for",n.for);break;default:s[t]=e}}const i=t=>{t instanceof Array?t.map(i):"string"==typeof t?s.textContent=t:s.appendChild(t)};return e.map(i),s},Wn=(...t)=>zn("div",Bn("form"),...t),kn=(t,...n)=>zn("div",Bn("form-group"),zn("label",null,t),...n),Un=(...t)=>zn("div",Bn("form-row"),...t),jn=(t,n,e)=>zn("div",Bn("input-group input-group-xs"),zn("div",Bn("input-group-prepend"),zn("span",Bn("input-group-text"),t)),zn("input",Object.assign({},n,{className:"form-control",type:"number",onchange:t=>{n.value=t.target.value,e(t.target.value)}}))),$n=(t,n,e)=>{const s=Hn();return t.map(t=>{const i=Hn();return zn("div",Bn("form-check"),zn("input",{className:"form-check-input",name:s.toString(),type:"radio",id:i.toString(),value:t.value,checked:t.value===n.value,onchange:t=>{n.value=t.target.value,e(t.target.value)}}),zn("label",{className:"form-check-label",for:i.toString()},t.label))})},Xn=(t,n,e)=>{const s=Hn();return zn("div",Bn("form-check"),zn("input",Object.assign({},n,{className:"form-check-input",type:"checkbox",id:s.toString(),onchange:t=>{n.checked=t.target.checked,e(t.target.checked)}})),zn("label",{className:"form-check-label",for:s.toString()},t))},Zn=new Float32Array([-1,1,-1,-1,1,1,1,-1]),Yn=(()=>{const t=new bt(!1,!1,4,xt.TRIANGLE_STRIP);return t.P=2,new Mt(Zn,t)})(),qn="\nprecision highp float;\n\nin vec2 a_pos;\nout vec2 v_pos;\nout vec2 tx_pos;\n\nvoid main() {\n    gl_Position = vec4(a_pos, 0., 1.);\n    v_pos = a_pos;\n    tx_pos = v_pos.xy * 0.5 + 0.5;\n}\n";class Kn{constructor(t,n){this.re=n,this.Us=new Wt(t,qn),this.Us.En(!1)}bind(t){}en(t){this.re.en(t)}}function Jn(){let t=new i(4);return i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function Qn(t,n,e,i){let o,r,a,h,l,u=n[0],c=n[1],f=n[2],m=n[3],d=e[0],p=e[1],_=e[2],S=e[3];return(r=u*d+c*p+f*_+m*S)<0&&(r=-r,d=-d,p=-p,_=-_,S=-S),1-r>s?(o=Math.acos(r),a=Math.sin(o),h=Math.sin((1-i)*o)/a,l=Math.sin(i*o)/a):(h=1-i,l=i),t[0]=h*u+l*d,t[1]=h*c+l*p,t[2]=h*f+l*_,t[3]=h*m+l*S,t}const te=x,ne=function(t,n){let e=n[0],s=n[1],i=n[2],o=n[3],r=e*e+s*s+i*i+o*o;return r>0&&(r=1/Math.sqrt(r),t[0]=e*r,t[1]=s*r,t[2]=i*r,t[3]=o*r),t};(function(){let t=o(),n=r(1,0,0),e=r(0,1,0)})(),function(){let t=Jn(),n=Jn()}(),function(){let t=function(){let t=new i(9);return i!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}()}();var ee=e(0);function se(t){return Math.trunc(255*t)}function ie(t,n){const e=t.RGBA,s=t.RGBA,i=t.UNSIGNED_BYTE,o=function(t){const n=rt;return n[0]=se(t[0]),n[1]=se(t[1]),n[2]=se(t[2]),n[3]=255,new Uint8Array(n)}(n);t.texImage2D(t.TEXTURE_2D,0,e,1,1,0,s,i,o)}class oe{constructor(t){this.Li=t}Ci(t){t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.Li),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_2D)}}function re(t,n){switch(n){case"dxt1":return t.COMPRESSED_RGB_S3TC_DXT1_EXT;case"dxt3":return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;case"dxt5":return t.COMPRESSED_RGBA_S3TC_DXT5_EXT;default:throw new Error("unsupported format "+n)}}class ae{constructor(t){this.data=t,this.Vi=ee(this.data)}Ci(t){const n=t.getExtension("WEBGL_compressed_texture_s3tc");if(!n)throw new Error("Compressed textures not supported, can't load WEBGL_compressed_texture_s3tc");for(let i=0;i<this.Vi.images.length;i++){const o=this.Vi.images[i],r=new Uint8Array(this.data,o.offset,o.length);var e=o.shape[0],s=o.shape[1];t.compressedTexImage2D(t.TEXTURE_2D,i,re(n,this.Vi.format),e,s,0,r)}t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR)}}class he{constructor(t,n,e){this.Ue=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.Ue),ie(t,e),this.Ii=n.then(n=>this.Di(t,n))}Ns(){return this.Ue}Hi(){return this.Ii}Di(t,n){t.bindTexture(t.TEXTURE_2D,this.Ue),n.Ci(t)}}const le=()=>new Map,ue=r(1,1,1);class ce{constructor(t,n,e){this.buffers=le(),this.Bi=le(),this.Gi=le(),this.images=le(),this.textures=le(),this.materials=le(),this.zi=le(),this.Wi=le(),this.ki=(t=>this.Ui+t),this.ji=(t=>pt(this.buffers,t,async t=>{const n=this.ki(this.$i.buffers[t].uri),e=await fetch(n);if(200!=e.status)throw new Error(`Unexpected response: ${e.status}`);const s=await e.arrayBuffer();return new Uint8Array(s)})),this.Xi=(t=>pt(this.Bi,t,async t=>{const n=this.$i.bufferViews[t],e=await this.ji(n.buffer),s=new Nt(this.yi,e.subarray(n.byteOffset,n.byteOffset+n.byteLength));return new Ft(s,n.byteLength)})),this.Zi=(t=>pt(this.Gi,t,async t=>{const n=this.$i.bufferViews[t],e=await this.ji(n.buffer),s=new At(this.yi,e.subarray(n.byteOffset,n.byteOffset+n.byteLength));return new Ft(s,n.byteLength)})),this.Yi=(t=>null==t?Promise.resolve(void 0):pt(this.zi,t,async t=>{const n=this.$i.accessors[t],e=await this.Xi(n.bufferView);return new Ot(n,e)})),this.Ui=e,this.$i=n,this.yi=t}async qi(t){void 0===t&&void 0===(t=this.$i.scene)&&(console.warn("Assuming the scene to load is 0 as it was not explicitly specified and GlTf has no default scene"),t=0);const n=new sn;return this.$i.scenes[t].nodes.forEach(t=>{n.we(this.Ki(t))}),n}Ji(t){return pt(this.images,t,t=>{const n=this.$i.images[t],e=this.ki(n.uri);switch(n.mimeType){case"image/vnd-ms.dds":return fetch(e).then(t=>{if(!t.ok)throw new Error(t.statusText);return t.arrayBuffer()}).then(t=>new ae(t));default:return new Promise((n,s)=>{const i=new Image;i.src=e,i.crossOrigin="anonymous",i.addEventListener("load",()=>{n(new oe(i))}),i.addEventListener("error",n=>{console.log(`error loading image ${t}`),s(n)})})}})}Qi(t){return null==t?Promise.resolve(void 0):pt(this.Wi,t,async t=>{const n=this.$i.accessors[t],e=await this.Zi(n.bufferView);return new Ot(n,e)})}to(t){return pt(this.textures,t,()=>{const n=this.$i.textures[t],e=this.Ji(n.source);return new he(this.yi,e,ue)})}no(t){return pt(this.materials,t,t=>{const n=new Sn,e=this.$i.materials[t],s=e.pbrMetallicRoughness;return s.baseColorFactor&&(s.baseColorTexture?n.Ke.Xe(x(...s.baseColorFactor)):b(n.Ke.value,s.baseColorFactor)),s.baseColorTexture&&n.Ke.qe(this.to(s.baseColorTexture.index)),s.metallicFactor&&(s.metallicRoughnessTexture?n.Je.je=s.metallicFactor:n.Je.value=s.metallicFactor),s.metallicRoughnessTexture&&(n.Je.Ue=this.to(s.metallicRoughnessTexture.index)),s.roughnessFactor&&(s.metallicRoughnessTexture?n.Qe.je=s.roughnessFactor:n.Qe.value=s.roughnessFactor),s.metallicRoughnessTexture&&(n.Qe.Ue=this.to(s.metallicRoughnessTexture.index)),e.normalTexture&&n.rs(this.to(e.normalTexture.index)),n})}eo(t){if(void 0!==t.mode&&t.mode!=E.TRIANGLES)throw new Error(`Not trianges: ${t.mode}`);const n=this.$i.accessors[t.attributes.POSITION],e=(new v).A(n.min).N(n.max);return Promise.all([this.Yi(t.indices),this.Qi(t.attributes.POSITION),this.Qi(t.attributes.TEXCOORD_0),this.Qi(t.attributes.NORMAL),this.Qi(t.attributes.TANGENT)]).then(([t,n,s,i,o])=>new Rt(this.yi,t,n,s,i,o,e))}Ki(t){const n=this.$i.nodes[t],e=new tn(n.name||t.toString());if(n.scale&&a(e.transform.scale,n.scale),n.translation&&a(e.transform.position,n.translation),n.rotation&&function(t,n){let e=2*Math.acos(n[3]),i=Math.sin(e/2);i>s?(t[0]=n[0]/i,t[1]=n[1]/i,t[2]=n[2]/i):(t[0]=1,t[1]=0,t[2]=0)}(e.transform.rotation,te(...n.rotation)),e.transform.update(),void 0!==n.mesh){const t=this.$i.meshes[n.mesh];let s=null;t.primitives.forEach((t,i)=>{this.eo(t).then(o=>{const r=o.nn(),a=new nn(`mesh ${n.mesh}, primitive ${i}`).Te(new Xt(o)).ye(new Zt(r)).Ae(new Qt(this.no(t.material))).$n(),h=null===s;s=Tt([r],!1,s,s),e.we(a),h&&(e.ht=new Zt(s).ie(!0))})})}return n.children&&n.children.forEach(t=>{const n=this.Ki(t);e.we(n)}),e}}async function fe(t,n){const e=await async function(t){const n=await fetch(t);if(!n.ok)throw new Error(`Error loading gltf from ${t}: ${n.statusText}`);return n.json()}(n);return new ce(t,e,function(t){const n=t.split("/");return 1===n.length?"./":(n.pop(),n.join("/")+"/")}(n))}const me=o(),de=Math.PI/2-.01,pe=t=>{console.error(t);const n=document.getElementById("error");n.innerText=t.toString(),n.style.display=""};function _e(){const t={so:{io:{value:1,min:0,max:1e3,step:1,oo:Gn()},ro:{ae:{value:60,min:0,step:.1,oo:Gn()}},new:{_t:{value:1.5,min:0,max:100,step:.1,oo:Gn()},ao:{value:1.5,min:0,max:100,step:.1,oo:Gn()},ae:{value:1,min:0,max:100,step:.1,oo:Gn()}}},ps:{enable:{oo:Gn(),checked:!0}},ds:{enable:{oo:Gn(),checked:!0},bias:{fixed:{value:.005,min:0,step:1e-4,oo:Gn()},qt:{value:.001,min:0,step:1e-4,oo:Gn()}}},ms:{enable:{oo:Gn(),checked:!0},Ce:{value:64,min:1,step:1,oo:Gn()},Ve:{value:4,min:2,step:1,oo:Gn()},_t:{value:1,min:.001,step:.1,oo:Gn()},bias:{value:.02,step:.001,min:.001,oo:Gn()},strength:{value:2,min:0,step:.5,oo:Gn()},Ie:{value:2,min:0,step:.5,oo:Gn()},De:{value:.3,min:0,step:.01,oo:Gn()},He:{value:.9,min:0,step:.05,oo:Gn()}},us:{value:bn.Final,oo:Gn(),options:[{label:"Final",value:bn.Final},{label:"Positions",value:bn.Positions},{label:"Normals",value:bn.Normals},{label:"SSAO",value:bn.SSAO},{label:"Color",value:bn.Color},{label:"Shadow Map",value:bn.ShadowMap},{label:"Metallic",value:bn.Metallic},{label:"Roughness",value:bn.Roughness},{label:"SSR",value:bn.SSR}]},ho:{oo:Gn(),checked:!0},cs:{oo:Gn(),checked:!0},fs:{oo:Gn(),checked:!0},pause:{oo:Gn(),checked:!1},materials:{},lo:{min:0,max:0,uo:0}},n=(t,n)=>jn(t,n,n.oo),e=document.getElementById("min-fps"),s=document.getElementById("max-fps"),i=document.getElementById("current-fps"),o=()=>{i.innerText=t.lo.uo.toFixed(2),e.innerText=t.lo.min.toFixed(2),s.innerText=t.lo.max.toFixed(2)};o(),document.getElementById("app").appendChild(Wn(Un(zn("div",Bn("col-lg"),kn("Features",Xn("Pause",t.pause,t.pause.oo),Xn("Rotate / animate",t.ho,t.ho.oo),Xn("SSAO",t.ms.enable,t.ms.enable.oo),Xn("Shadow Map",t.ds.enable,t.ds.enable.oo),Xn("Normal maps",t.cs,t.cs.oo),Xn("Albedo textures",t.fs,t.fs.oo),Xn("Screen-space reflections",t.ps.enable,t.ps.enable.oo)),kn("Layer to show",$n(t.us.options,t.us,t.us.oo)),kn("SSAO",n("Samples",t.ms.Ce),n("Noise scale",t.ms.Ve),n("Radius",t.ms._t),n("Bias",t.ms.bias),n("Strength",t.ms.strength),n("Scale power",t.ms.Ie)),kn("SSAO Blur",n("Pos. threshold",t.ms.De),n("Normal threshold",t.ms.He))),zn("div",Bn("col-lg"),kn("Shadow Map",n("Fixed bias",t.ds.bias.fixed),n("Normal bias",t.ds.bias.qt)),kn("Lighting",n("Light count",t.so.io)),kn("Sun",n("Intensity",t.so.ro.ae)),kn("New lights",n("Radius",t.so.new._t),n("Pos scale",t.so.new.ao),n("Intensity",t.so.new.ae))))));const a=document.getElementById("gl"),f=function(t){let n=t.getContext("webgl2",{co:!1});return n.getExtension("EXT_color_buffer_float"),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n}(a),m=new Pt(f,Yn),d=new Kn(f,m),S=new Ut(f,d),g=new jt(f,S);var v=1,w=0;f.clearColor(0,0,0,1),f.clear(f.COLOR_BUFFER_BIT|f.DEPTH_BUFFER_BIT),g.qn(f);const x=({headers:t,length:n})=>{if(t)v=parseInt(t.get("content-length"));else{const t=(w+=n)/v;g.Kn(f,t)}};Promise.all([Ct("resources/sphere.obj",x).then(t=>t.gn().Ft(f)),Ct("resources/plane.obj",x).then(t=>t.gn().Ft(f))]).then(([n,e])=>{const s=new q(f.canvas.width/f.canvas.height);s.position=r(0,0,-3);const i=new mn,m=new vn,S=new wn,g=()=>{const n=i,e=t.ms;n.strength=e.strength.value,n.Ie=e.Ie.value,n.bias=e.bias.value,n._t=e._t.value,n.Ve=e.Ve.value,n.Ce=e.Ce.value,n.enabled=t.ms.enable.checked,n.He=t.ms.He.value,n.De=t.ms.De.value};g();const v=()=>{const n=m,e=t.ds;n.enabled=e.enable.checked,n.ls=e.bias.qt.value,n.hs=e.bias.fixed.value};v();const w=()=>{S.enabled=t.ps.enable.checked};w();const x=new dn(f,i),b=new xn;b.ms=i,b.ds=m,b.ps=S,b.us=t.us.value,b.cs=t.cs.checked,b.fs=t.fs.checked;const T=new In(f,b,d,n,x);let M=new sn;t.cs.oo.Pi=(t=>{b.cs=t}),t.fs.oo.Pi=(t=>{b.fs=t}),async function(t,n){return(await fe(t,n)).qi()}(f,z).then(t=>{(M=t).Ne.push(E.ve),h(s.position,-6.4035325050354,1.3013536930084229,-.20439213514328003),h(s.forward,1,0,0),s.st()},t=>{pe(t)});const E=new nn("sun").Me(new qt).$n();E.ve.direction=c(E.ve.direction,[-1,-1,-1]),E.ve.ae=t.so.ro.ae.value,M.Ne.push(E.ve);let y=1e3/60,A=null,N=0;function F(n){t.pause.checked||(null===A?(y=1e3/60,A=n):(y=n-A,A=n),t.lo.uo=1e3/y,N%100==0?(t.lo.min=t.lo.uo,t.lo.max=t.lo.uo):(t.lo.min=Math.min(t.lo.min,t.lo.uo),t.lo.max=Math.max(t.lo.max,t.lo.uo)),++N%5==0&&o(),L.forEach((t,n)=>{const e=.003*y;switch(n){case"e":u(ot,s.Y,e),l(s.position,s.position,ot),s.update();break;case"z":u(ot,s.Y,-e),l(s.position,s.position,ot),s.update();break;case"w":u(ot,s.forward,e),l(s.position,s.position,ot),s.update();break;case"s":u(ot,s.forward,-e),l(s.position,s.position,ot),s.update();break;case"a":u(ot,s.right(),-e),l(s.position,s.position,ot),s.update();break;case"d":u(ot,s.right(),e),l(s.position,s.position,ot),s.update()}}),t.ho.checked&&c(E.ve.direction,[-.5,-.95,.25*Math.sin(n/8e3)]),ft(s,M),T.Kn(M,s),requestAnimationFrame(F))}var O=1,R=0,P=0;const L=new Map;window.onkeydown=(t=>{L.set(t.key,!0)}),window.onkeyup=(t=>{L.delete(t.key)});var C=s.U;a.onwheel=(t=>{if(t.ctrlKey)O=K(O+t.deltaY*s.U*1e-4,.1,1.9),s.U=C*O,s.update();else if(t.shiftKey)u(ot,s.Y,.01*-t.deltaY),l(s.position,s.position,ot),u(ot,s.right(),.01*t.deltaX),l(s.position,s.position,ot),s.update();else{R+=1e-4*t.deltaY*s.U,P-=1e-4*t.deltaX*s.U,R=K(R,-de,de);let n=r(0,0,1),e=r(0,1,0);p(n,n,me,R),_(n,n,me,P),p(e,e,me,R),_(e,e,me,P),s.forward=n,s.Y=e,s.update()}t.preventDefault()}),t.ps.enable.oo.Pi=w;const V=()=>{g(),x.Ge(f,i),T.zs()};t.ms.Ce.oo.Pi=V,t.ms.Ve.oo.Pi=V,t.ms.Ie.oo.Pi=V,t.ms.strength.oo.Pi=((t,n)=>{T.bs.ms.strength=t,0!==t&&0!==n||T.Hs()}),t.ms.bias.oo.Pi=g,t.ms._t.oo.Pi=g,t.ms.De.oo.Pi=g,t.ms.He.oo.Pi=g,t.ms.enable.oo.Pi=(t=>{T.bs.ms.enabled=t,console.log("SSAOState enabled",T.bs.ms.enabled),T.Hs()}),t.ds.bias.fixed.oo.Pi=v,t.ds.bias.qt.oo.Pi=v,t.ds.enable.oo.Pi=(t=>{T.bs.ds.enabled=t,console.log("shadowmap enabled",T.bs.ds.enabled),T.Hs()}),t.so.ro.ae.oo.Pi=(t=>{E.ve.ae=t}),t.so.io.oo.Pi=(n=>{n=K(n,0,500),console.log(M.pt.length);const e=M.pt.length-n;if(e>0)for(let t=0;t<e;t++)M.pt.pop();else if(e<0)for(let n=0;n<-e;n++){const n=en(t.so.new.ao.value,t.so.new.ae.value);n._t=t.so.new._t.value,M.pt.push(n)}console.log("new point light count "+M.pt.length)}),t.so.io.oo(t.so.io.value),t.us.oo.Pi=(t=>{const n=bn[t];console.log("setting show layer to "+n),T.bs.us=parseInt(t),T.Hs()}),t.pause.oo.Pi=(t=>{t||(A=null,requestAnimationFrame(F))}),requestAnimationFrame(F)}).catch(pe)}window.addEventListener("load",()=>{try{_e()}catch(t){pe(t)}})}]);
//# sourceMappingURL=bundle.js.map